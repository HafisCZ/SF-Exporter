<!DOCTYPE html>
<html lang="en">
    <head>
        <title>SFTools - Dungeon Simulator</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/png" href="res/favicon.png"/>

        <link rel="stylesheet" href="vendor/css/semantic.min.css"/>
        <link rel="stylesheet" href="css/style.css"/>
        <link rel="stylesheet" href="css/dungeons.css"/>
        <link rel="stylesheet" href="css/editor.css"/>
        <link rel="stylesheet" href="css/utility.css"/>

        <link href="https://fonts.googleapis.com/css?family=Roboto:300&display=swap" rel="stylesheet">

        <script src="vendor/js/jquery.3.4.1.min.js"></script>
        <script src="vendor/js/semantic.min.js"></script>
        <script src="vendor/js/chart.min.js"></script>
        <script src="vendor/js/html2canvas.min.js"></script>
        <script src="vendor/js/sentry.bundle.min.js"></script>

        <script src="js/enum.js"></script>
        <script src="js/util.js"></script>
        <script src="js/lang.js"></script>

        <script src="js/core/util.js"></script>
        <script src="js/core/playa.js"></script>
        <script src="js/core/core.js"></script>
        <script src="js/plugins.js"></script>
        <script src="js/core/idb.js"></script>
        <script src="js/core/ast.js"></script>
        <script src="js/stats/settings.js"></script>
        <script src="endpoint/endpoint.js"></script>

        <script src="js/changelog.js"></script>
        <script src="js/views.js"></script>

        <script src="js/sim/dungeon_data.js"></script>
        <script src="js/editor.js"></script>
        
        <script type="text/javascript">
            LOGICAL_PROCS = (navigator || {}).hardwareConcurrency || 4;
        </script>

        <script src="js/sim/base.js"></script>
        <script src="js/sim/debug_utils.js"></script>
    </head>
    <body>
        <div class="ui fixed borderless huge menu css-menu" style="z-index: 3;">
            <div class="header item"><a class="css-a-blank" href="index.html">SFTools</a></div>
            <a class="item" href="https://github.com/HafisCZ/sf-tools/wiki/%5BWIP%5D-Tools-Overview#dungeon-simulator" target="_blank"><i class="ui icon book"></i> Wiki - How to use</a>
            <div class="right menu" id="show-right-menu">
                <a class="item" id="cheat-menu-toggle"><i class="ui angle double left icon"></i></a>
            </div>
        </div>

        <div class="paste-target" onpaste="console.log" data-intl="simulator.paste_target#"></div>

        <div class="ui main container">
            <div class="ui two columns stackable grid">
                <!-- Player edit field -->
                <div class="column">
                    <div class="ui form" id="sim-editor">

                    </div>
                </div>
                <!-- Player list -->
                <div class="column">
                    <div class="ui grid">
                        <div class="row">
                            <div class="six wide column">
                                <div class="ui small form">
                                    <div class="two fields">
                                        <div class="field" data-position="bottom center" data-intl-tooltip="simulator.threads">
                                            <input class="text-center fluid" type="text" id="sim-threads" value="2">
                                        </div>
                                        <div class="field" data-position="bottom center" data-intl-tooltip="simulator.iterations">
                                            <span style="position: absolute; top: 0.5em; left: -0.25em;">x</span>
                                            <input class="text-center fluid" type="text" id="sim-iterations" value="5000">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="ten wide column">
                                <div class="compact-buttons" style="display: flex; flex-direction: row;">
                                    <button class="ui fluid button" type="submit" id="sim-run" data-intl="dungeons.simulate_one"></button>
                                    <button class="ui fluid button" type="submit" id="sim-run-dungeon" data-intl="dungeons.simulate_remaining"></button>
                                    <button class="ui fluid button disabled" type="submit" id="sim-run-all" data-intl="dungeons.simulate_all"></button>
                                    <button class="ui fluid button disabled" type="submit" id="sim-run-next" data-intl="dungeons.simulate_next" data-intl-tooltip="dungeons.simulate_next_settings.tooltip" data-position="bottom center"></button>
                                </div>
                            </div>
                        </div>
                        <div class="row padding-none">
                            <div class="eight wide text-center column" data-intl="dungeons.player"></div>
                            <div class="eight wide text-center column" data-intl="dungeons.enemy"></div>
                        </div>
                        <div class="row padding-none">
                            <div class="sixteen wide column">
                                <hr/>
                            </div>
                        </div>
                        <div class="row">
                            <div class="eight wide column">
                                <div class="ui middle aligned grid" id="sim-players1">

                                </div>
                            </div>
                            <div class="eight wide column">
                                <div class="ui form" style="margin-top: -0.4em;">
                                    <div class="field">
                                        <div class="ui fluid search selection dropdown" id="dungeon-list">
                                          <div class="text"></div>
                                          <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                    <div class="field" style="margin-top: 1.25em;">
                                        <div class="ui fluid search selection dropdown" id="boss-list">
                                          <div class="text"></div>
                                          <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                    <div class="field disabled" style="margin-top: 3.7em;">
                                        <label data-intl="dungeons.open"></label>
                                        <div class="ui fluid search selection dropdown" id="available-list">
                                          <div class="text"></div>
                                          <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row" style="padding-top: 0;">
                            <div class="sixteen wide column" style="position: relative;">
                                <div style="position: absolute; left: 0.5em; bottom: -1.5em; font-size: 80%; opacity: 50%;" data-intl="dungeons.graph.y"></div>
                                <div style="position: absolute; left: 37%; bottom: -1.5em; font-size: 80%; opacity: 50%;" data-intl="dungeons.graph.x"></div>
                                <canvas id="winchart" style="width: 100%; height: 17.75em;"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="results-modal" class="ui mini modal" style="width: 400px;">
            <div class="header" data-intl="dungeons.results"></div>
            <button id="save-screenshot" class="ui small basic icon button" style="position: absolute; right: .75em; top: 1em;" data-position="bottom center" data-intl-tooltip="stats.copy.image"><i class="download icon"></i></button>
            <div class="experience"></div>
            <div style="padding-left: 1em; padding-right: 1em; border-bottom: 1px solid rgba(34,36,38,.15)">
                <canvas id="list-winchart" style="width: 100%;"></canvas>
            </div>
            <div class="content" style="max-height: 65vh; overflow-y: auto;">

            </div>
        </div>

        <div id="cheat-menu" style="position: fixed; right: 0; top: 0; height: 100vh; width: 300px; background: #313131; z-index: 2; display: none; padding-top: 4.5em;">
            <h3 class="ui header white centered" data-intl="dungeons.cheats.title"></h3>
            <p style="font-size: 85%; color: white; text-align: center;" data-intl="dungeons.cheats.subtitle"></p>
            <div class="ui small white form" style="padding-left: 15px; padding-top: 1em; border-top: 1px white solid;">
                <div class="field">
                    <div class="ui checkbox">
                        <input type="checkbox" class="hidden" id="cheats-enabled">
                        <label data-intl="dungeons.cheats.enable"></label>
                    </div>
                </div>
                <div class="field"><h3 class="ui white header" data-intl="dungeons.cheats.general"></h3></div>
                <div class="field">
                    <div class="ui checkbox">
                        <input type="checkbox" class="hidden" data-cheat="enchantments">
                        <label data-intl="dungeons.cheats.enchantments"></label>
                    </div>
                </div>
                <div class="field">
                    <div class="ui checkbox">
                        <input type="checkbox" class="hidden" data-cheat="runes">
                        <label data-intl="dungeons.cheats.runes"></label>
                    </div>
                </div>
                <div class="field">
                    <div class="ui checkbox">
                        <input type="checkbox" class="hidden" data-cheat="pets">
                        <label data-intl="dungeons.cheats.pets"></label>
                    </div>
                </div>
                <div class="field"><h3 class="ui white header" data-intl="dungeons.cheats.potions"></h3></div>
                <div class="two fields">
                    <div class="field">
                        <div class="ui checkbox">
                            <input type="checkbox" class="hidden" data-cheat="strength">
                            <label data-intl="general.attribute1"></label>
                        </div>
                    </div>
                    <div class="field">
                        <div class="ui checkbox">
                            <input type="checkbox" class="hidden" data-cheat="dexterity">
                            <label data-intl="general.attribute2"></label>
                        </div>
                    </div>
                </div>
                <div class="two fields">
                    <div class="field">
                        <div class="ui checkbox">
                            <input type="checkbox" class="hidden" data-cheat="intelligence">
                            <label data-intl="general.attribute3"></label>
                        </div>
                    </div>
                    <div class="field">
                        <div class="ui checkbox">
                            <input type="checkbox" class="hidden" data-cheat="constitution">
                            <label data-intl="general.attribute4"></label>
                        </div>
                    </div>
                </div>
                <div class="two fields">
                    <div class="field">
                        <div class="ui checkbox">
                            <input type="checkbox" class="hidden" data-cheat="luck">
                            <label data-intl="general.attribute5"></label>
                        </div>
                    </div>
                    <div class="field">
                        <div class="ui checkbox">
                            <input type="checkbox" class="hidden" data-cheat="life">
                            <label data-intl="general.life_potion"></label>
                        </div>
                    </div>
                </div>
                <div class="field"><h3 class="ui white header" data-intl="dungeons.cheats.class"></h3></div>
                <div class="field" style="margin-right: 1em;">
                    <div class="ui selection compact dropdown" data-cheat="class">
                        <div class="text"></div>
                        <i class="dropdown icon"></i>
                    </div>
                </div>
            </div>
        </div>

        <script type="text/javascript">
            const SIMULATOR_THRESHOLD_DIALOG = new (class extends Dialog {
                _createModal () {
                    return `
                        <div class="ui basic tiny modal" style="background-color: #ffffff; padding: 1em; margin: -2em; border-radius: 0.5em; border: 1px solid #0b0c0c;">
                            <h2 class="ui header" style="color: black; padding-bottom: 0.5em; padding-top: 0; padding-left: 0;">${intl(`dungeons.simulate_next_settings.title`)}</h2>
                            <div class="ui form" style="line-height: 1.3em; margin-bottom: 1em;">
                                <div class="field">
                                    <label>${intl(`dungeons.simulate_next_settings.label`)}</label>
                                    <div class="ui range small slider" data-op="slider"></div>
                                </div>
                                <div class="two fields">
                                    <div class="field">
                                        <label>${intl(`general.min`)}</label>
                                        <div class="ui input">
                                            <input type="text" data-op="min">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label>${intl(`general.max`)}</label>
                                        <div class="ui input">
                                            <input type="text" data-op="max">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="ui two fluid buttons">
                                <button class="ui black fluid button" data-op="cancel">${intl('dialog.shared.cancel')}</button>
                                <button class="ui fluid button" style="background-color: orange; color: black;" data-op="ok">${intl('dialog.shared.ok')}</button>
                            </div>
                        </div>
                    `;
                }

                _validatedValue ($input, minValue, maxValue) {
                    const value = Number($input.val());
                    if (isNaN(value) || value < minValue || value > maxValue) {
                        $input.closest('.field').addClass('error');

                        return null;
                    } else {
                        $input.closest('.field').removeClass('error');

                        return Math.round(value * 10) / 10;
                    }
                }

                _update (updateInputs) {
                    this.$slider.slider('set rangeValue', this.currentMin, this.currentMax, updateInputs);
                }

                _createBindings () {
                    this.$slider = this.$parent.find('[data-op="slider"]');
                    this.$slider.slider({
                        min: 0,
                        max: 100,
                        step: 0.1
                    });

                    this.$slider.slider('setting', 'onMove', (_span, min, max) => {
                        this.currentMin = Math.round(min * 10) / 10;
                        this.currentMax = Math.round(max * 10) / 10;

                        this.$min.val(this.currentMin);
                        this.$max.val(this.currentMax);
                    });
                
                    this.$min = this.$parent.find('[data-op="min"]');
                    this.$min.on('input', () => {
                        const value = this._validatedValue(this.$min, 0, this.currentMax);
                        if (value) {
                            this.currentMin = value;
                            this._update(false);
                        }
                    });
                    
                    this.$max = this.$parent.find('[data-op="max"]');
                    this.$max.on('input', () => {
                        const value = this._validatedValue(this.$max, this.currentMin, 100);
                        if (value) {
                            this.currentMax = value;
                            this._update(false);
                        }
                    });

                    this.$okButton = this.$parent.find('[data-op="ok"');
                    this.$okButton.click(() => {
                        this.callback(
                            this.currentMin,
                            this.currentMax
                        );

                        this.close();
                    });

                    this.$cancelButton = this.$parent.find('[data-op="cancel"]');
                    this.$cancelButton.click(() => {
                        this.close();
                    });
                }

                _applyArguments (currentMin, currentMax, callback) {
                    this.currentMin = currentMin;
                    this.currentMax = currentMax;
                    this.callback = callback;

                    this._update(true);
                }
            })

            Site.ready(function (urlParams) {
                $('#cheat-menu-toggle').click(() => {
                    $('#cheat-menu').transition('fade left');
                    $('#cheat-menu-toggle .icon').toggleClass('left right');
                });
                $('#cheat-menu .checkbox').checkbox('set unchecked');

                function randomizeString (orig) {
                    let str = ''
                    for (let i = 0; i < orig.length; i++) {
                        if (/[a-z]/.test(orig[i])) {
                            str += 'abcdefghijklmnopqrstuvwxyz'.charAt(Math.floor(Math.random() * 26));
                        } else if (/[A-Z]/.test(orig[i])) {
                            str += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.charAt(Math.floor(Math.random() * 26));
                        } else {
                            str += orig[i];
                        }
                    }
                    return str;
                }

                let shouldRandomizeNames = new Date().getMonth() == 3 && new Date().getDate() == 1;

                for (let dungeon of Object.values(DUNGEON_DATA)) {
                    dungeon.name = intl(`dungeon_enemies.${dungeon.key}.name`);
                    if (shouldRandomizeNames) {
                        dungeon.name = randomizeString(dungeon.name);
                    }

                    for (let enemy of Object.values(dungeon.floors)) {
                        enemy.name = intl(`dungeon_enemies.${dungeon.key}.${enemy.pos}`);
                        if (shouldRandomizeNames) {
                            enemy.name = randomizeString(enemy.name);
                        }
                    }
                }

                let ignoreChanges = false;
                function withoutUpdate (func) {
                    ignoreChanges = true;
                    func();
                    ignoreChanges = false;
                }

                $('#sim-threads').captiveInputField('dungeon_sim/threads', 4, v => !isNaN(v) && v >= 1);
                $('#sim-iterations').captiveInputField('dungeon_sim/iterations', 5000, v => !isNaN(v) && v >= 1);

                $('#sim-run-next').contextmenu((e) => {
                    e.preventDefault();

                    DialogController.open(
                        SIMULATOR_THRESHOLD_DIALOG,
                        SharedPreferences.getRaw('dungeon_sim/threshold', 5),
                        SharedPreferences.getRaw('dungeon_sim/threshold_max', 100),
                        (min, max) => {
                            SharedPreferences.setRaw('dungeon_sim/threshold', min)
                            SharedPreferences.setRaw('dungeon_sim/threshold_max', max)
                        }
                    );
                });

                let helperNames = ['player', 'bert', 'mark', 'kunigunde'].map(k => intl(`dungeons.${k}`));

                let editor = new (class extends Editor {
                    constructor ($parent, callback) {
                        super($parent, callback);

                        this.fields['name'].editable(false);
                    }

                    fill (object, index = 0) {
                        this.pauseListener();

                        super.fill(object);

                        if (index > 0) {
                            this.fields['class'].set(index);
                        }

                        this.morph.show(index == 0);

                        this.fields['class'].toggle(index == 0);
                        this.fields['gladiator'].toggle(index == 0);
                        this.fields['portal_hp'].toggle(index == 0);
                        this.fields['portal_damage'].toggle(index == 0);
                        this.fields['potion_life'].toggle(index == 0);
                        this.fields['level'].toggle(index == 0);
                        this.fields['shield'].show(object.Class == 1 && index == 0);
                        this.fields['name'].set(helperNames[index]);

                        this.resumeListener();
                    }

                    _morph (newClass) {
                        super._morph(newClass);

                        saveEditor();
                        settingsChanged();
                    }
                })($('#sim-editor'), () => {
                    saveEditor();
                    settingsChanged();
                });

                // On paste event handler
                var players = [ editor.empty(1), editor.empty(1), editor.empty(2), editor.empty(3) ];

                var boss_current = null;
                var boss = null;
                var dungeon_current = null;
                var dungeon = null;
                var availableBosses = null;
                var log = urlParams.has('log');

                SimulatorUtils.configure(
                    CONFIG,
                    urlParams.has('debug'),
                    (config) => {
                        const data = players.map((p) => {
                            let m = toSimulatorModel(p);
                            if (p.Class == 1 && typeof p.BlockChance != 'undefined') {
                                m.BlockChance = p.BlockChance;
                            }

                            return m;
                        });

                        copyJSON({
                            config,
                            data,
                            type: 'custom'
                        });
                    }
                )

                function settingsChanged () {
                    $('#winchart').addClass('faded-out');
                }

                function getBossRunes (runes) {
                    let values = [0, 0, 0];

                    if (runes && runes.res) {
                        if (Array.isArray(runes.res)) {
                            values = runes.res;
                        } else {
                            values[runes.type - 40] = runes.res;
                        }
                    }

                    return {
                        Health: 0,
                        ResistanceFire: values[0],
                        ResistanceCold: values[1],
                        ResistanceLightning: values[2]
                    }
                }

                function getBossData (data, dungeon) {
                    return {
                        ForceArmor: data.armor ? 0 : (dungeon.armor_multiplier || 1),
                        Armor: data.armor,
                        Class: data.class,
                        Mask: 0,
                        Instrument: 0,
                        Name: data.name,
                        Level: data.level,
                        ForceHealth: data.health,
                        NoBaseDamage: true,
                        Identifier: 999,
                        Strength: { Total: data.str },
                        Dexterity: { Total: data.dex },
                        Intelligence: { Total: data.int },
                        Constitution: { Total: data.con },
                        Luck: { Total: data.lck },
                        Dungeons: { Player: 0, Group: 0 },
                        Fortress: { Gladiator: data.gladiator || 0 },
                        Potions: { Life: 0 },
                        Runes: getBossRunes(data.runes),
                        Items: {
                            Hand: {},
                            Wpn1: {
                                AttributeTypes: { 2: data.runes ? data.runes.type : 0 },
                                Attributes: { 2: data.runes ? data.runes.damage : 0 },
                                DamageMax: data.max,
                                DamageMin: data.min,
                                HasEnchantment: false
                            },
                            Wpn2: {
                                AttributeTypes: { 2: data.runes ? data.runes.type : 0 },
                                Attributes: { 2: data.runes ? data.runes.damage : 0 },
                                DamageMax: data.max,
                                DamageMin: data.min,
                                HasEnchantment: false
                            }
                        }
                    };
                }

                function getDisplayRunes (runes) {
                    if (runes) {
                        let displayType = ['F', 'C', 'L'][ runes.type - 40 ];

                        let displayDamage = `${runes.damage} ${displayType}`;

                        let displayResistance = '';
                        if (Array.isArray(runes.res)) {
                            displayResistance = ` / ${['F', 'C', 'L'].map((type, index) => `${runes.res[index]} ${type}`).join('&nbsp; ')}`;
                        } else if (runes.res) {
                            displayResistance = ` / ${runes.res} ${displayType}`;
                        }

                        return `<span class="boss-rune">${displayDamage}${displayResistance}</span>`;
                    } else {
                        return '';
                    }
                }

                $('#dungeon-list').dropdown({
                    values: _sort_asc(Object.entries(DUNGEON_DATA), ([id, dungeon]) => dungeon.pos).map(([ id, dungeon ]) => {
                        return {
                            name: dungeon.shadow ? `<span style="text-shadow:0px 0px 8px #390074;">${dungeon.name}<span>` : dungeon.name,
                            value: id,
                            disabled: Object.keys(dungeon.floors).length == 0
                        };
                    })
                }).dropdown('setting', 'onChange', (value, text) => {
                    dungeon_current = value;
                    dungeon = DUNGEON_DATA[value];

                    $('#boss-list').dropdown({
                        values: Object.entries(dungeon.floors).map(([ id, _boss ]) => {
                            return {
                                name: `<span${ dungeon.shadow ? ' style="text-shadow:0px 0px 8px #390074;"' : '' }>
                                           <img class="ui centered image boss-image" style="position: absolute; right: 0; height: 2.5em; top: 0; width: 2.5em;" src="res/class${ _boss.class }.png">
                                           ${ _boss.pos }. ${ _boss.name }
                                           ${ getDisplayRunes(_boss.runes) }
                                       <span>`,
                                value: id
                            };
                        })
                    }).dropdown('setting', 'onChange', (value, text) => {
                        if (!ignoreChanges) {
                            $('#available-list').dropdown('clear');
                        }

                        settingsChanged();

                        dungeon = DUNGEON_DATA[dungeon_current];
                        boss = dungeon.floors[value];
                        boss_current = boss;
                    }).dropdown('set selected', Object.keys(dungeon.floors)[0]);
                    show();
                }).dropdown('set selected', '1');

                var selected = 0;

                $(document.body).on('paste', function (event) {
                    if (event.target.type != 'text') {
                        try {
                            showData(SimulatorUtils.handlePaste(JSON.parse(event.originalEvent.clipboardData.getData('text'))));
                        } catch (e) {
                            // Do nothing
                        }
                    }
                });

                $('#sim-editor input').on('paste', function (event) { event.stopPropagation(); });

                function loadEditor (data) {
                    SFItem.forceCorrectRune(data.Items.Wpn1);
                    SFItem.forceCorrectRune(data.Items.Wpn2);

                    if (data.Class == 1 && typeof data.BlockChance == 'undefined') data.BlockChance = data.Items.Wpn2.DamageMin;
                    if (data.Class != 4) data.Items.Wpn2 = SFItem.empty();

                    if (selected > 0) {
                        for (var key of ['gladiator', 'level', 'portal_hp', 'portal_damage', 'potion_life']) {
                            var path = editor.fields[key].path();
                            setObjectAt(data, path, getObjectAt(players[0], path));
                        }
                    }

                    editor.fill(data, selected);
                }

                function saveEditor () {
                    if (editor.valid()) {
                        var obj = editor.read();
                        if (selected == 0) {
                            for (var key of ['gladiator', 'level', 'portal_hp', 'portal_damage', 'potion_life']) {
                                var path = editor.fields[key].path();

                                setObjectAt(players[1], path, getObjectAt(obj, path));
                                setObjectAt(players[2], path, getObjectAt(obj, path));
                                setObjectAt(players[3], path, getObjectAt(obj, path));
                            }
                        }

                        players[selected] = obj;
                    }
                }

                // Show fighters
                function show () {
                    var content1 = '';

                    for (var i = 0; i < 4; i++) {
                        content1 += `
                            <div class="row selectable ${ selected == i ? 'selected' : 'nselected' }" data-index="${ i }">
                                <div class="four wide text-center column">
                                    <img class="ui medium centered image" style="width: 50px; opacity: ${ i == 0 || dungeon.shadow ? '100' : '25' }%;" src="res/portrait${ i ? i : '' }.png">
                                </div>
                                <div class="eight wide column text-center">
                                    <b>${intl(`dungeons.${['yourself', 'bert', 'mark', 'kunigunde'][i]}`)}</b>
                                </div>
                                <div class="four wide column">
                                </div>
                            </div>
                        `;
                    }

                    $('#sim-players1').html(content1);

                    $('[data-index]').click(function () {
                        select(Number($(this).attr('data-index')));
                    });
                }

                function select (index) {
                    selected = index;

                    editor.fill(players[selected], selected);
                    show();
                }

                select(0);

                const chart = new Chart($('#winchart'), {
                    type:'line',data:{datasets:[{fill:!1,borderWidth:1.5,data:[]}]},options:{title:{display:!0},legend:{display:!1},scales:{yAxes:[{display:!0,ticks:{min:0,max:100,padding:10,stepSize:20,callback:function(value,index,values){return `${ value }%`}}}],xAxes:[{display:!1}]},tooltips:{enabled:!1},animation:{duration:0},events:[],hover:{animationDuration:0,},showTooltips:!1,responsiveAnimationDuration:0,elements:{line:{borderColor:'black',tension:0},point:{radius:0}}}
                });

                const chartList = new Chart($('#list-winchart'), {
                    type:'line',data:{datasets:[{fill:!1,borderWidth:1.5,data:[]}]},options:{title:{display:!0},legend:{display:!1},scales:{yAxes:[{display:!0,ticks:{min:0,max:100,padding:10,stepSize:20,display:!1}}],xAxes:[{display:!1}]},tooltips:{enabled:!1},animation:{duration:0},events:[],hover:{animationDuration:0,},showTooltips:!1,responsiveAnimationDuration:0,elements:{line:{borderColor:'black',tension:0},point:{radius:0}}}
                });

                function showData (data) {
                    let oldSelected = selected;
                    if (Array.isArray(data)) {
                        for (let i = 0; i < 4; i++) {
                            selected = i;
                            loadEditor(data[i]);
                            saveEditor();
                        }

                        selected = oldSelected;
                        loadEditor(data[selected]);

                        show();
                    } else if (data.Class) {
                        loadEditor(data);
                        saveEditor();
                    }

                    settingsChanged();
                }

                const DUNGEON_ARR_TO_DID = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ];

                function getDungeonEnemyAt (dungeon, isShadow, enemyIndex) {
                    if (enemyIndex < 0) {
                        return null;
                    } else {
                        let id = dungeon + (isShadow ? 100 : 0);
                        let dung = DUNGEON_DATA[id];
                        let boss = Object.entries(dung.floors)[enemyIndex];
                        if (boss) {
                            return {
                                id,
                                dungeon: dung,
                                boss: boss[1]
                            };
                        } else {
                            return null;
                        }
                    }
                }

                function getSpecialDungeonEnemyAt (dungeon, enemyIndex, soft = false) {
                    if (enemyIndex < 0) {
                        return null;
                    } else {
                        let floors = DUNGEON_DATA[dungeon].floors;
                        let boss = null;
                        if (soft) {
                            boss = Object.entries(floors).find(x => x[1].pos == enemyIndex);
                        } else {
                            boss = Object.entries(floors)[enemyIndex];
                        }

                        if (boss) {
                            return {
                                id: dungeon,
                                dungeon: DUNGEON_DATA[dungeon],
                                boss: boss[1]
                            }
                        } else {
                            return null;
                        }
                    }
                }

                let cheatsEnabled = false;
                let cheatsWasEnabled = false;

                $('#cheats-enabled').closest('.checkbox').change((el) => {
                    cheatsEnabled = el.target.checked;
                    if (cheatsEnabled) {
                        cheatsWasEnabled = true;
                    }
                });

                StatisticsIntegration.configure(
                    SELF_PROFILE,
                    intl('simulator.poll.players'),
                    function ($statsList) {
                        for (let player of _sort_des(DatabaseManager.getLatestPlayers(), p => p.Timestamp)) {
                            $statsList.append($(`
                                <div class="ui fluid button basic vertical animated gray" style="margin-top: 0.5em;">
                                    <div class="visible content">
                                        <span style="color: black;">${player.Name} @ ${player.Prefix}</span>
                                    </div>
                                    <div class="hidden content">
                                        <span style="color: black;">${intl('editor.level')} ${player.Level} ${intl(`general.class${player.Class}`)}</span>
                                    </div>
                                </div>
                                `).click(() => {
                                    dungeon = DUNGEON_DATA[dungeon_current];
                                    boss = boss_current;

                                    if (cheatsWasEnabled) {
                                        DatabaseManager._addPlayer(player.Data);
                                        player = DatabaseManager.getPlayer(player.Identifier, player.Timestamp);

                                        cheatsWasEnabled = false;
                                    }

                                    if (cheatsEnabled) {
                                        applyCheats(player);

                                        cheatsWasEnabled = true;
                                    }

                                    showData(player.toSimulatorShadowModel());

                                    let normalDungeons = player.Dungeons.Normal;
                                    let shadowDungeons = player.Dungeons.Shadow;
                                    let tower = player.Dungeons.Tower;
                                    let youtube = player.Dungeons.Youtube;
                                    let twister = player.Dungeons.Twister + 1;

                                    availableBosses = [
                                        ... normalDungeons.map((dungeon, index) => getDungeonEnemyAt(DUNGEON_ARR_TO_DID[index], false, dungeon)),
                                        getSpecialDungeonEnemyAt(201, player.Dungeons.Normal.Total < 90 ? -1 : tower),
                                        getSpecialDungeonEnemyAt(203, twister, true),
                                        ... shadowDungeons.map((dungeon, index) => getDungeonEnemyAt(DUNGEON_ARR_TO_DID[index], true, dungeon)),
                                        getSpecialDungeonEnemyAt(202, youtube),
                                    ].filter(boss => boss);

                                    if (availableBosses.length) {
                                        $('#available-list').parent('.field').removeClass('disabled');
                                        $('#sim-run-all, #sim-run-next').removeClass('disabled');
                                        $('#available-list').dropdown({
                                            values: _sort_asc(availableBosses, ({ dungeon: _dungeon }) => _dungeon.pos).map(({ dungeon: _dungeon, boss: _boss }, index) => {
                                                return {
                                                    name: `<span${ _dungeon.shadow ? ' style="text-shadow:0px 0px 8px #390074;"' : '' }>
                                                               <img class="ui centered image boss-image" style="position: absolute; right: 0; height: 2.5em; top: 0; width: 2.5em;" src="res/class${ _boss.class }.png">&nbsp;
                                                                   <span class="boss-dungeon-name">${ _dungeon.name }</span>
                                                                   <span class="boss-name">${ _boss.pos }. ${ _boss.name }</span>
                                                                   ${ getDisplayRunes(_boss.runes) }
                                                           <span>`,
                                                    value: index
                                                };
                                            })
                                        }).dropdown('setting', 'onChange', (value, text) => {
                                            if (!isNaN(value) && value && value.length > 0) {
                                                settingsChanged();

                                                let sel = availableBosses[value];

                                                dungeon = sel.dungeon;
                                                boss = sel.boss;

                                                withoutUpdate(() => {
                                                    $('#dungeon-list').dropdown('set selected', sel.id);
                                                    $('#boss-list').dropdown('set selected', sel.boss.pos);
                                                });
                                            }
                                        });
                                    } else {
                                        $('#available-list').parent('.field').addClass('disabled');
                                        $('#sim-run-all, #sim-run-next').addClass('disabled');
                                    }
                                }
                            ));
                        }
                    }
                )

                function showMassDungeonResults (bosses, results, sort, calculateTotalExperience) {
                    let entries = bosses.map((dungeon, index) => {
                        let result = _dig(results, index);
                        if (result) {
                            return Object.assign(result, dungeon);
                        } else {
                            return false;
                        }
                    }).filter(v => v);

                    if (sort === 'extended') {
                        let sortedBosses = [];
                        for (let entry of entries) {
                            let { score, boss, dungeon, id } = entry;

                            let lowerChanceIndex = sortedBosses.findIndex(({ score: _score }) => _score < score);
                            let index = sortedBosses.length;

                            if (lowerChanceIndex != -1) {
                                let sameDungeonIndex = sortedBosses.findLastIndex(({ dungeon: _dungeon, boss: _boss, id: _id }) => (id in NEXT_DUNGEONS_INVERTED) ? ((_id === id && _boss.pos < boss.pos) || (_id === NEXT_DUNGEONS_INVERTED[id])) : (_id === id && _boss.pos < boss.pos));
                                if (sameDungeonIndex != -1) {
                                    index = Math.max(lowerChanceIndex, sameDungeonIndex + 1);
                                } else {
                                    index = lowerChanceIndex;
                                }
                            }

                            sortedBosses.splice(index, 0, entry);
                        }

                        entries = sortedBosses;
                    } else if (sort) {
                        entries.sort((b, a) => a.score - b.score);
                    }

                    if (calculateTotalExperience) {
                        let experienceTotal = _mapped_sum(entries, ({ id, boss, dungeon }) => {
                            if (id == 201) {
                                return 0;
                            } else if (boss.level >= 393) {
                                return 3E8;
                            } else {
                                return ExperienceRequired[boss.level] / 5;
                            }
                        }, 0);
                        let experience = formatAsSpacedNumber(experienceTotal, ' ');

                        $('#results-modal .experience').html(`<div>${intl('dungeons.experience', { experience })}</div>`);
                    } else {
                        $('#results-modal .experience').empty();
                    }

                    $('#results-modal .content').html(`
                        <div class="ui grid">
                            ${ entries.map(({ boss, dungeon, score, healths, iterations }, index) => {
                                return `
                                    <div class="row" data-id="${index}" style="padding: 0;">
                                        <div class="eleven wide column" style="position: relative; padding-top: 1rem; padding-bottom: 1rem;">
                                            <span${ dungeon.shadow ? ' style="text-shadow:0px 0px 8px #390074;"' : '' }>
                                                <img class="ui centered image boss-image" style="position: absolute; left: 0; height: 2.5em; top: 0.5em; width: 2.5em;" src="res/class${ boss.class }.png">&nbsp;
                                                <span style="position: absolute; left: 3.75em; top: 0.4em; font-size: 80%;">${ dungeon.name }</span>
                                                <span style="position: absolute; left: 3em; top: 1.4em;">#${boss.pos} - ${ boss.name }</span>
                                            </span>
                                        </div>
                                        <div class="five wide column text-center" style="padding-top: 1rem; padding-bottom: 1rem;">${ score == 0 ? 'Not possible' : `${ (100 * score / iterations).toFixed(2) }%` }</div>
                                    </div>
                                `;
                            }).join('') }
                        </div>
                    `);
                    $('#results-modal .content .row').mouseenter((event) => {
                        let index = event.currentTarget.dataset.id;
                        let { boss, dungeon, score, healths, iterations, id } = entries[index];
                        showGraph(chartList, dungeon, boss, score, iterations, healths, id != 201);
                    });
                    $('#results-modal .content .row').first().trigger('mouseenter');
                    $('#results-modal').modal('show');
                }

                function preparePlayerInstances (dungeon) {
                    let playerInstances = players.map(p => JSON.parse(JSON.stringify(p)));

                    if (dungeon.shadow) {
                        let bert = playerInstances[1];

                        let hp_a = (100 + bert.Dungeons.Player) / 100;
                        let hp_b = (100 + bert.Potions.Life) / 100;
                        let hp_c = (100 + bert.Runes.Health) / 100;
                        let hp_d = 1.22;

                        playerInstances[1].BlockChance = 0;
                        playerInstances[1].ForceHealth = Math.trunc(Math.floor(bert.Constitution.Total * 5 * (bert.Level + 1) * hp_a) * hp_b * hp_c * hp_d);
                    }

                    return dungeon.shadow ? [ ... playerInstances.slice(1, 4), playerInstances[0] ] : [ playerInstances[0] ];
                }

                $('#sim-run-all').click(async function () {
                    if (availableBosses && availableBosses.length > 0 && editor.valid()) {
                        Loader.toggle(true, { progress: true });

                        let results = [];
                        let resultsRemaining = availableBosses.length;

                        let maximumInstances = Math.max(1, Number($('#sim-threads').val()) || LOGICAL_PROCS);
                        let iterations = Math.max(1, Number($('#sim-iterations').val()) || 5000);

                        let pendingInstances = [];

                        const updateProgress = () => {
                            Loader.progress(results.filter(r => r).length / availableBosses.length);
                        }

                        for (let [index, { boss, dungeon, name }] of Object.entries(availableBosses)) {
                            let worker = await Workers.createSimulatorWorker('dungeons');

                            worker.addEventListener('message', (message) => {
                                let { score, iterations, healths } = message.data.results;

                                results[message.data.index] = {
                                    score,
                                    healths,
                                    iterations
                                };

                                updateProgress();

                                if (--resultsRemaining <= 0) {
                                    Loader.toggle(false);
                                    showMassDungeonResults(availableBosses, results, true, true);
                                } else if (pendingInstances.length > 0) {
                                    let [ secWorker, args ] = pendingInstances.pop();
                                    secWorker.postMessage(args);
                                }
                            }, false);

                            pendingInstances.push([worker, {
                                players: preparePlayerInstances(dungeon),
                                boss: getBossData(boss, dungeon),
                                iterations: iterations,
                                index: index,
                                hpcap: 500,
                                config: SimulatorUtils.config
                            }])
                        }

                        let currentInstances = Math.min(maximumInstances, pendingInstances.length);
                        for (let i = 0; i < currentInstances; i++) {
                            let [ worker, args ] = pendingInstances.pop();
                            worker.postMessage(args);
                        }
                    }
                });

                const NEXT_DUNGEONS = {
                    13: 30,
                    113: 130,
                    14: 27,
                    114: 127,
                    16: 28,
                    116: 128,
                    17: 29,
                    117: 129
                };

                const NEXT_DUNGEONS_INVERTED = _invert(NEXT_DUNGEONS, true);

                $('#sim-run-next').click(async function () {
                    if (availableBosses && availableBosses.length > 0 && editor.valid()) {
                        Loader.toggle(true, { progress: true });

                        let maximumInstances = Math.max(1, Number($('#sim-threads').val()) || LOGICAL_PROCS);
                        let iterations = Math.max(1, Number($('#sim-iterations').val()) || 5000);

                        let threshold_min = _clamp(Number(SharedPreferences.getRaw('dungeon_sim/threshold', 5)), 0, 100);
                        let threshold_max = _clamp(Number(SharedPreferences.getRaw('dungeon_sim/threshold_max', 5)), threshold_min, 100);

                        let dungeonStacks = [];
                        for (let { boss: _boss, dungeon: _dungeon, id: _id } of availableBosses) {
                            if (_id === 203) {
                                // Ignore twister
                                continue;
                            }

                            let dungeonStack = [];

                            for (let bossData of Object.values(_dungeon.floors)) {
                                if (dungeonStack.length > 0 || bossData.pos == _boss.pos) {
                                    dungeonStack.push({
                                        id: _id,
                                        dungeon: _dungeon,
                                        boss: bossData
                                    })
                                }
                            }

                            if (_id in NEXT_DUNGEONS) {
                                let nextId = NEXT_DUNGEONS[_id];
                                let nextDungeon = DUNGEON_DATA[nextId];

                                for (let bossData of Object.values(nextDungeon.floors)) {
                                    dungeonStack.push({
                                        id: nextId,
                                        dungeon: nextDungeon,
                                        boss: bossData
                                    })
                                }
                            }

                            dungeonStacks.push(dungeonStack);
                        }

                        let floorStacks = [];
                        for (let i = 0; i < Math.max(...dungeonStacks.map(s => s.length)); i++) {
                            floorStacks[i] = [];

                            for (let j = 0; j < dungeonStacks.length; j++) {
                                if (dungeonStacks[j][i]) {
                                    floorStacks[i].push(dungeonStacks[j][i]);
                                }
                            }
                        }

                        let currentStack = null;
                        let pendingStacks = [];

                        let results = [];
                        let resultsTotal = 0;
                        let resultsRemaining = 0;
                        let resultsRemainingStack = 0;

                        const updateProgress = () => {
                            Loader.progress((resultsTotal - resultsRemaining) / resultsTotal);
                        }

                        for (let stack of floorStacks) {
                            let tempStack = [];

                            for (let { boss, dungeon, id } of stack) {
                                let worker = await Workers.createSimulatorWorker('dungeons');

                                worker.addEventListener('message', (message) => {
                                    let { score, iterations, healths } = message.data.results;

                                    if (score < threshold_min * iterations / 100 || score > threshold_max * iterations / 100) {
                                        for (let i = 0; i < pendingStacks.length; i++) {
                                            pendingStacks[i] = pendingStacks[i].filter(({ worker: _worker, args: _args }) => {
                                                if (_args.id === id || _args.id === NEXT_DUNGEONS[id]) {
                                                    _worker.terminate();

                                                    return --resultsRemaining && false;
                                                } else {
                                                    return true;
                                                }
                                            })
                                        }

                                        pendingStacks = pendingStacks.filter((_stack) => _stack.length > 0);
                                    } else {
                                        results[message.data.index] = {
                                            score,
                                            healths,
                                            iterations
                                        };
                                    }

                                    resultsRemaining--;
                                    resultsRemainingStack--;

                                    updateProgress();

                                    if (resultsRemaining <= 0) {
                                        Loader.toggle(false);

                                        if (results.length > 0) {
                                            showMassDungeonResults(floorStacks.flat(), results, 'extended', true);
                                        } else {
                                            Toast.info(intl('dungeons.simulate_next_info.title', { threshold_min, threshold_max }), intl('dungeons.simulate_next_info.message#'));
                                        }
                                    } else if (resultsRemainingStack <= 0 && pendingStacks.length > 0) {
                                        currentStack = pendingStacks.shift();
                                        resultsRemainingStack = currentStack.length;

                                        for (let i = 0; i < Math.min(currentStack.length, maximumInstances); i++) {
                                            let { worker: _worker, args: _args } = currentStack.shift();
                                            _worker.postMessage(_args);
                                        }
                                    } else if (currentStack.length > 0) {
                                        let { worker: _worker, args: _args } = currentStack.shift();
                                        _worker.postMessage(_args);
                                    }
                                }, false);

                                tempStack.push({
                                    worker,
                                    args: {
                                        players: preparePlayerInstances(dungeon),
                                        boss: getBossData(boss, dungeon),
                                        iterations: iterations,
                                        index: resultsRemaining++,
                                        hpcap: 500,
                                        config: SimulatorUtils.config,
                                        id
                                    }
                                })
                            }

                            pendingStacks.push(tempStack);
                        }

                        resultsTotal = resultsRemaining;

                        currentStack = pendingStacks.shift();
                        resultsRemainingStack = currentStack.length;

                        for (let i = 0; i < Math.min(currentStack.length, maximumInstances); i++) {
                            let { worker, args } = currentStack.shift();
                            worker.postMessage(args);
                        }
                    }
                });

                $('#sim-run-dungeon').click(async function () {
                    if (editor.valid()) {
                        Loader.toggle(true, { progress: true });

                        let bossQueue = [];
                        for (let bossData of Object.values(dungeon.floors)) {
                            if (bossQueue.length > 0 || bossData.pos == boss.pos) {
                                bossQueue.push({
                                    dungeon,
                                    boss: bossData
                                })
                            }
                        }

                        let resultsRemaining = bossQueue.length;

                        let maximumInstances = Math.max(1, Number($('#sim-threads').val()) || LOGICAL_PROCS);
                        let iterations = Math.max(1, Number($('#sim-iterations').val()) || 5000);

                        let results = [];
                        let pendingInstances = [];

                        const updateProgress = () => {
                            Loader.progress(results.filter(r => r).length / bossQueue.length);
                        }

                        for (let [index, { boss, dungeon }] of Object.entries(bossQueue)) {
                            let worker = await Workers.createSimulatorWorker('dungeons');

                            worker.addEventListener('message', (message) => {
                                let { score, iterations, healths } = message.data.results;

                                results[message.data.index] = {
                                    score,
                                    healths,
                                    iterations
                                };

                                updateProgress();

                                if (--resultsRemaining <= 0) {
                                    Loader.toggle(false);
                                    showMassDungeonResults(bossQueue, results, false, true);
                                } else if (pendingInstances.length > 0) {
                                    let [ secWorker, args ] = pendingInstances.pop();
                                    secWorker.postMessage(args);
                                }
                            }, false);

                            pendingInstances.push([worker, {
                                players: preparePlayerInstances(dungeon),
                                boss: getBossData(boss, dungeon),
                                iterations: iterations,
                                index: index,
                                hpcap: 500,
                                config: SimulatorUtils.config
                            }])
                        }

                        let currentInstances = Math.min(maximumInstances, pendingInstances.length);
                        for (let i = 0; i < currentInstances; i++) {
                            let [ worker, args ] = pendingInstances.pop();
                            worker.postMessage(args);
                        }
                    }
                })

                $('#sim-run').click(async function () {
                    if (boss && editor.valid()) {
                        Loader.toggle(true, { progress: true });

                        let bossInstance = getBossData(boss, dungeon);
                        let playerInstances = preparePlayerInstances(dungeon);
                        let threads = Math.max(1, Number($('#sim-threads').val()) || 2);
                        let iterations = Math.max(1, Number($('#sim-iterations').val()) || 5000);

                        let results = [];
                        let totalScore = 0;
                        let totalTries = 0;

                        if (log) {
                            threads = 1;
                            iterations = 2000;
                        }

                        const updateProgress = () => {
                            Loader.progress(totalTries / (threads * iterations));
                        }

                        for (let i = 0; i < threads; i++) {
                            let worker = await Workers.createSimulatorWorker('dungeons');

                            worker.addEventListener('message', (message) => {
                                let { score, iterations, healths } = message.data.results;
                                if (message.data.log.length) {
                                    download('logs.json', new Blob([ JSON.stringify({
                                        fights: message.data.log,
                                        players: players,
                                        boss: bossInstance
                                    }) ], {
                                        type: 'application/json'
                                    }));
                                }

                                results.push(healths)
                                totalScore += score;
                                totalTries += iterations;

                                updateProgress();

                                if (totalTries == threads * iterations) {
                                    let finalResults = new Array(results[0].length);
                                    for (let i = 0; i < results[0].length; i++) {
                                        let healthsSum = 0;
                                        for (let j = 0; j < threads; j++) {
                                            healthsSum += results[j][i];
                                        }

                                        finalResults[i] = healthsSum / threads;
                                    }

                                    showGraph(chart, dungeon, boss, totalScore, totalTries, _sort_asc(finalResults));
                                    $('#winchart').removeClass('faded-out');
                                    Loader.toggle(false);
                                }
                            }, false);

                            worker.postMessage({
                                players: playerInstances,
                                boss: bossInstance,
                                iterations: iterations,
                                log: log,
                                config: SimulatorUtils.config
                            });
                        }
                    }
                });

                function showGraph (graph, dungeon, boss, score, tries, healths, showExperience = false) {
                    graph.options.title.text = [
                        `${ dungeon.shadow ? `${intl('dungeon_enemies.shadow')} ` : '' }${ dungeon.name }: ${ boss.name }`,
                        intl('dungeons.graph.winrate', { rate: (100 * score / tries).toFixed(2), score: formatAsSpacedNumber(score, ' '), tries: formatAsSpacedNumber(tries, ' ') })
                    ];

                    if (showExperience) {
                        let experience = boss.level >= 393 ? 3E8 : ExperienceRequired[boss.level] / 5;
                        graph.options.title.text.splice(1, 0, `${formatAsSpacedNumber(experience, ' ')} XP`);
                    }

                    graph.data.datasets[0].data = healths.map((h, i) => { return { x: i, y: h * 100 }; });
                    graph.data.labels = healths.map((a, b) => b);
                    graph.update(0);
                }

                $('#save-screenshot').click(function () {
                    let target = document.querySelector('#results-modal .content');

                    target.style['overflow-y'] = '';
                    target.style['max-height'] = '';

                    html2canvas(target, {
                        logging: false,
                        onclone: doc => {
                            target.style['overflow-y'] = 'auto';
                            target.style['max-height'] = '70vh';
                        }
                    }).then(canvas => {
                        canvas.toBlob(blob => {
                            window.download(`dungeons_${Date.now()}.png`, blob);
                        });
                    });
                });

                $('[data-cheat="class"]').dropdown({
                    preserveHTML: true,
                    values: [
                        {
                            name: intl('dungeons.cheats.keep_original'),
                            value: 0
                        },
                        ... Object.keys(CLASS_MAP).map((e) => {
                            return {
                                name: `<img class="ui centered image class-picture" src="res/class${e}.png">${intl(`general.class${e}`)}`,
                                value: e
                            };
                        })
                    ]
                }).dropdown('set selected', '0');

                function applyCheat (player, callback) {
                    const models = [player];
                    if (player.Companions) {
                        models.push(...Object.values(player.Companions));
                    }

                    models.forEach(callback);
                }

                function applyCheats (player) {
                    let cheats = _array_to_hash($('[data-cheat]').toArray(), el => [el.dataset.cheat, el.tagName == 'DIV' ? parseInt($(el).dropdown('get value')) : el.checked]);

                    if (cheats.pets) {
                        applyCheat(player, model => {
                            model.Pets = {
                                Water: 40,
                                Light: 40,
                                Earth: 40,
                                Shadow: 40,
                                Fire: 40
                            };
                        });
                    }

                    if (cheats.enchantments) {
                        applyCheat(player, model => {
                            for (let item of Object.values(model.Items)) {
                                item.HasEnchantment = true;
                            };
                        });
                    }

                    // Set potions to player
                    const potions = _compact(['strength', 'dexterity', 'intelligence', 'constitution', 'luck', 'life'].map((type, i) => cheats[type] ? (i + 1) : null))
                    if (potions.length) {
                        applyCheat(player, model => {
                            const potionGroup = potions.slice(0, 3);

                            model.Potions = potionGroup.map(type => ({ Type: type, Size: 25 }));
                            model.Potions.Life = potionGroup.includes(6) ? 25 : 0;
                        });
                    }

                    if (cheats.class) {
                        const swapAttributes = function (obj, type, fromClass, toClass) {
                            let attributes = _array_to_hash(['Main', 'Side1', 'Side2'], kind => [kind, _dig(obj, MAIN_ATTRIBUTE_MAP[kind][fromClass - 1], type)]);
                            for (let kind of ['Main', 'Side1', 'Side2']) {
                                obj[MAIN_ATTRIBUTE_MAP[kind][toClass - 1]][type] = attributes[kind];
                            }
                        }

                        const scaleValue = function (value, mapping, fromClass, toClass) {
                            return Math.ceil(value / (mapping[fromClass - 1]) * (mapping[toClass - 1]));
                        }

                        // Morph all items to desired class
                        const getAttributeID = (klass) => ({
                            'Strength': 1,
                            'Dexterity': 2,
                            'Intelligence': 3
                        })[MAIN_ATTRIBUTE_MAP['Main'][klass - 1]];

                        for (const [type, item] of Object.entries(player.Items)) {
                            player.Items[type] = item.morph(getAttributeID(player.Class), getAttributeID(cheats.class), true);
                        }

                        // Swap attributes
                        swapAttributes(player, 'Base', player.Class, cheats.class);
                        swapAttributes(player, 'Total', player.Class, cheats.class);

                        // Scale damage & armor
                        player.Armor = scaleValue(player.Armor, [50, 10, 25, 25, 10, 25, 50, 25, 25], player.Class, cheats.class);
                        player.Items.Wpn1.DamageMin = scaleValue(player.Items.Wpn1.DamageMin, [2, 4.5, 2.5, 2, 2, 2, 2.5, 4.5, 4.5], player.Class, cheats.class);
                        player.Items.Wpn1.DamageMax = scaleValue(player.Items.Wpn1.DamageMax, [2, 4.5, 2.5, 2, 2, 2, 2.5, 4.5, 4.5], player.Class, cheats.class);

                        // Set per-class data
                        if (cheats.class == 1 /* WARRIOR */) {
                            player.Items.Wpn2.DamageMin = 25;
                        } else if (cheats.class == 4 /* ASSASSIN */) {
                            player.Items.Wpn2 = player.Items.Wpn1;
                        } else if (cheats.class == 8 /* DRUID */) {
                            player.Mask = 2;
                        } else if (cheats.class == 9 /* BARD */) {
                            player.Instrument = 0;
                        }

                        player.Class = cheats.class;
                    }

                    if (potions.length > 0 || cheats.pets || cheats.class) {
                        applyCheat(player, model => {
                            // Remove pre-calculated bonus
                            for (let type of ['Strength', 'Dexterity', 'Intelligence', 'Constitution', 'Luck']) {
                                model[type].Bonus = undefined;
                            }

                            // Evaluate commons
                            if (model instanceof SFCompanion) {
                                model.evaluateCompanionCommon(player);
                            } else {
                                model.evaluateCommon();
                            }
                        });
                    }

                    if (cheats.runes) {
                        applyCheat(player, model => {
                            model.Runes.Health = 15;
                            model.Runes.ResistanceFire = 75;
                            model.Runes.ResistanceCold = 75;
                            model.Runes.ResistanceLightning = 75;
                            model.Items.Wpn1.Attributes[2] = 60;
                            model.Items.Wpn2.Attributes[2] = 60;
                        });
                    }
                }

                function convertBossToSimulatorFormat (rawData, rawDungeon) {
                    return _tap(getBossData(rawData, rawDungeon), function (data) {
                        let level = data.Level;
                        let health = data.ForceHealth;
                        let healthMultiplier = [5, 2, 4, 4, 5, 4, 4, [3, 5, 4][data.Mask], 2][data.Class - 1];

                        data.Constitution.Total = Math.ceil(health / (healthMultiplier * (level + 1)));

                        if (typeof data.Armor === 'undefined') {
                            let armorMultiplier = [50, 10, 25, 25, 10, 25, 50, [10, 50, 25][data.Mask], 25][data.Class - 1];

                            data.Armor = armorMultiplier * level * (rawDungeon.armor_multiplier || 1.0);
                        }

                        if (data.Class === 1) {
                            data.BlockChance = 25;
                        }
                    })
                }

                return {
                    currentBoss: () => convertBossToSimulatorFormat(boss, dungeon),
                    currentDungeon: () => Object.values(dungeon.floors).map(b => convertBossToSimulatorFormat(b, dungeon))
                };
            });
        </script>
    </body>
</html>
