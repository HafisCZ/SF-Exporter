<!DOCTYPE html>
<html lang="en">
    <head>
        <title>SFTools - Dungeon Simulator</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/png" href="res/favicon.png"/>

        <link rel="stylesheet" href="css/pages/dungeons.css"/>

        <script src="vendor/js/jquery.3.4.1.min.js"></script>
        <script src="vendor/js/semantic.min.js"></script>
        <script src="vendor/js/chart.min.js"></script>
        <script src="vendor/js/html2canvas.min.js"></script>
        <script src="vendor/js/sentry.bundle.min.js"></script>

        <script src="js/enum.js"></script>
        <script src="js/util.js"></script>

        <script src="js/core/util.js"></script>
        <script src="js/core/models.js"></script>
        <script src="js/core/core.js"></script>
        <script src="js/plugins.js"></script>
        <script src="js/core/idb.js"></script>
        <script src="js/core/ast.js"></script>
        <script src="js/stats/settings.js"></script>        
        <script src="js/changelog.js"></script>
        <script src="js/views.js"></script>
        <script src="endpoint/endpoint.js"></script>

        <script src="js/sim/dungeon_data.js"></script>
        <script src="js/editor.js"></script>

        <script src="js/sim/base.js"></script>
        <script src="js/sim/debug_utils.js"></script>
    </head>
    <body class="inverted">
        <div class="ui fixed inverted borderless huge menu" style="z-index: 3;">
            <div class="header item"><a href="index.html">SFTools</a></div>
            <a class="item" href="https://github.com/HafisCZ/sf-tools/wiki/%5BWIP%5D-Tools-Overview#dungeon-simulator" target="_blank"><i class="ui icon book"></i> Wiki - How to use</a>
            <div class="right menu" id="show-right-menu">
                <a class="item" id="cheat-menu-toggle"><i class="ui angle double left icon"></i></a>
            </div>
        </div>

        <div class="paste-target" onpaste="console.log" data-intl="simulator.paste_target#"></div>

        <div class="ui main inverted container">
            <div class="ui two columns stackable grid">
                <!-- Player edit field -->
                <div class="column">
                    <div class="ui inverted form" id="sim-editor">

                    </div>
                </div>
                <!-- Player list -->
                <div class="column">
                    <div class="ui grid">
                        <div class="row">
                            <div class="six wide column">
                                <div class="ui small inverted form">
                                    <div class="two fields">
                                        <div class="field" data-position="bottom center" data-intl-tooltip="simulator.threads" data-inverted="">
                                            <div class="ui inverted centered input">
                                                <input type="text" id="sim-threads" value="2">
                                            </div>
                                        </div>
                                        <div class="field" data-position="bottom center" data-intl-tooltip="simulator.iterations" data-inverted="">
                                            <span style="position: absolute; top: 0.5em; left: -0.25em;">x</span>
                                            <div class="ui inverted centered input">
                                                <input type="text" id="sim-iterations" value="5000">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="ten wide column">
                                <div class="compact-buttons" style="display: flex; flex-direction: row;">
                                    <button class="ui fluid basic inverted button" type="submit" id="sim-run" data-intl="dungeons.simulate_one"></button>
                                    <button class="ui fluid basic inverted button" type="submit" id="sim-run-dungeon" data-intl="dungeons.simulate_remaining"></button>
                                    <button class="ui fluid basic inverted button disabled" type="submit" id="sim-run-all" data-intl="dungeons.simulate_all"></button>
                                    <button class="ui fluid basic inverted button disabled" type="submit" id="sim-run-next" data-intl="dungeons.simulate_next" data-intl-tooltip="dungeons.simulate_next_settings.tooltip" data-inverted="" data-position="bottom center"></button>
                                </div>
                            </div>
                        </div>
                        <div class="row !p-0">
                            <div class="eight wide text-center column" data-intl="dungeons.player"></div>
                            <div class="eight wide text-center column" data-intl="dungeons.enemy"></div>
                        </div>
                        <div class="row !p-0">
                            <div class="sixteen wide column">
                                <hr/>
                            </div>
                        </div>
                        <div class="row">
                            <div class="eight wide column">
                                <div class="ui middle aligned grid" id="sim-players1">

                                </div>
                            </div>
                            <div class="eight wide column">
                                <div class="ui inverted form" style="margin-top: -0.4em;">
                                    <div class="field">
                                        <div class="ui fluid search selection inverted dropdown" id="dungeon-list">
                                          <div class="text"></div>
                                          <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                    <div class="field" style="margin-top: 1.25em;">
                                        <div class="ui fluid search selection inverted dropdown" id="boss-list">
                                          <div class="text"></div>
                                          <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                    <div class="field disabled" style="margin-top: 3.7em;">
                                        <label data-intl="dungeons.open"></label>
                                        <div class="ui fluid search selection inverted dropdown" id="available-list">
                                          <div class="text"></div>
                                          <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row" style="padding-top: 0;">
                            <div class="sixteen wide column" style="position: relative;">
                                <div style="position: absolute; left: 0.5em; bottom: -1.5em; font-size: 80%; opacity: 50%;" data-intl="dungeons.graph.y"></div>
                                <div style="position: absolute; left: 37%; bottom: -1.5em; font-size: 80%; opacity: 50%;" data-intl="dungeons.graph.x"></div>
                                <canvas id="winchart" style="width: 100%; height: 17.75em;"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="cheat-menu" style="position: fixed; right: 0; top: 0; height: 100vh; width: 300px; background: #313131; z-index: 2; display: none; padding-top: 4.5em;">
            <h3 class="ui header inverted centered" data-intl="dungeons.cheats.title"></h3>
            <p style="font-size: 85%; color: white; text-align: center;" data-intl="dungeons.cheats.subtitle"></p>
            <div class="ui small inverted form" style="padding-left: 15px; padding-top: 1em; border-top: 1px white solid;">
                <div class="field">
                    <div class="ui checkbox">
                        <input type="checkbox" class="hidden" id="cheats-enabled">
                        <label data-intl="dungeons.cheats.enable"></label>
                    </div>
                </div>
                <div class="field"><h3 class="ui inverted header" data-intl="dungeons.cheats.general"></h3></div>
                <div class="field">
                    <div class="ui checkbox">
                        <input type="checkbox" class="hidden" data-cheat="enchantments">
                        <label data-intl="dungeons.cheats.enchantments"></label>
                    </div>
                </div>
                <div class="field">
                    <div class="ui checkbox">
                        <input type="checkbox" class="hidden" data-cheat="runes">
                        <label data-intl="dungeons.cheats.runes"></label>
                    </div>
                </div>
                <div class="field">
                    <div class="ui checkbox">
                        <input type="checkbox" class="hidden" data-cheat="pets">
                        <label data-intl="dungeons.cheats.pets"></label>
                    </div>
                </div>
                <div class="field"><h3 class="ui inverted header" data-intl="dungeons.cheats.potions"></h3></div>
                <div class="two fields">
                    <div class="field">
                        <div class="ui checkbox !mt-0">
                            <input type="checkbox" class="hidden" data-cheat="strength">
                            <label data-intl="general.attribute1"></label>
                        </div>
                    </div>
                    <div class="field">
                        <div class="ui checkbox !mt-0">
                            <input type="checkbox" class="hidden" data-cheat="dexterity">
                            <label data-intl="general.attribute2"></label>
                        </div>
                    </div>
                </div>
                <div class="two fields">
                    <div class="field">
                        <div class="ui checkbox !mt-0">
                            <input type="checkbox" class="hidden" data-cheat="intelligence">
                            <label data-intl="general.attribute3"></label>
                        </div>
                    </div>
                    <div class="field">
                        <div class="ui checkbox !mt-0">
                            <input type="checkbox" class="hidden" data-cheat="constitution">
                            <label data-intl="general.attribute4"></label>
                        </div>
                    </div>
                </div>
                <div class="two fields">
                    <div class="field">
                        <div class="ui checkbox !mt-0">
                            <input type="checkbox" class="hidden" data-cheat="luck">
                            <label data-intl="general.attribute5"></label>
                        </div>
                    </div>
                    <div class="field">
                        <div class="ui checkbox !mt-0">
                            <input type="checkbox" class="hidden" data-cheat="life">
                            <label data-intl="general.life_potion"></label>
                        </div>
                    </div>
                </div>
                <div class="field"><h3 class="ui inverted header" data-intl="dungeons.cheats.class"></h3></div>
                <div class="field" style="margin-right: 1em;">
                    <div class="ui selection inverted dropdown" data-cheat="class">
                        <div class="text"></div>
                        <i class="dropdown icon"></i>
                    </div>
                </div>
            </div>
        </div>

        <script type="text/javascript">
            const SIMULATOR_THRESHOLD_DIALOG = new (class extends Dialog {
                _createModal () {
                    return `
                        <div class="small inverted bordered dialog">
                            <div class="header">${intl(`dungeons.simulate_next_settings.title`)}</div>
                            <div class="ui inverted form">
                                <div class="field">
                                    <label>${intl(`dungeons.simulate_next_settings.label`)}</label>
                                    <div class="ui range small inverted slider" data-op="slider"></div>
                                </div>
                                <div class="two fields">
                                    <div class="field">
                                        <label>${intl(`general.min`)}</label>
                                        <div class="ui inverted input">
                                            <input type="text" data-op="min">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label>${intl(`general.max`)}</label>
                                        <div class="ui inverted input">
                                            <input type="text" data-op="max">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="ui two fluid buttons">
                                <button class="ui black button" data-op="cancel">${intl('dialog.shared.cancel')}</button>
                                <button class="ui button !text-black !background-orange" data-op="ok">${intl('dialog.shared.ok')}</button>
                            </div>
                        </div>
                    `;
                }

                _validatedValue ($input, minValue, maxValue) {
                    const value = Number($input.val());
                    if (isNaN(value) || value < minValue || value > maxValue) {
                        $input.closest('.field').addClass('error');

                        return null;
                    } else {
                        $input.closest('.field').removeClass('error');

                        return Math.round(value * 10) / 10;
                    }
                }

                _update (updateInputs) {
                    this.$slider.slider('set rangeValue', this.currentMin, this.currentMax, updateInputs);
                }

                _createBindings () {
                    this.$slider = this.$parent.find('[data-op="slider"]');
                    this.$slider.slider({
                        min: 0,
                        max: 100,
                        step: 0.1
                    });

                    this.$slider.slider('setting', 'onMove', (_span, min, max) => {
                        this.currentMin = Math.round(min * 10) / 10;
                        this.currentMax = Math.round(max * 10) / 10;

                        this.$min.val(this.currentMin);
                        this.$max.val(this.currentMax);
                    });
                
                    this.$min = this.$parent.find('[data-op="min"]');
                    this.$min.on('input', () => {
                        const value = this._validatedValue(this.$min, 0, this.currentMax);
                        if (value) {
                            this.currentMin = value;
                            this._update(false);
                        }
                    });
                    
                    this.$max = this.$parent.find('[data-op="max"]');
                    this.$max.on('input', () => {
                        const value = this._validatedValue(this.$max, this.currentMin, 100);
                        if (value) {
                            this.currentMax = value;
                            this._update(false);
                        }
                    });

                    this.$okButton = this.$parent.find('[data-op="ok"');
                    this.$okButton.click(() => {
                        this.callback(
                            this.currentMin,
                            this.currentMax
                        );

                        this.close();
                    });

                    this.$cancelButton = this.$parent.find('[data-op="cancel"]');
                    this.$cancelButton.click(() => {
                        this.close();
                    });
                }

                _applyArguments (currentMin, currentMax, callback) {
                    this.currentMin = currentMin;
                    this.currentMax = currentMax;
                    this.callback = callback;

                    this._update(true);
                }
            })()

            const SIMULATOR_RESULTS_DIALOG = new (class extends Dialog {
                constructor () {
                    super({
                        dismissable: true
                    })
                }

                _createModal () {
                    return `
                        <div class="tight inverted bordered very small dialog">
                            <div class="header flex justify-content-between !p-2" style="border-bottom: 1px solid #262626;">
                                <div>${intl(`dungeons.results`)}</div>
                                <div data-op="screenshot" class="ui tiny basic inverted icon button" data-position="bottom center" data-tooltip="${intl('stats.copy.image')}">
                                    <i class="download icon"></i>
                                </div>
                            </div>
                            <div data-op="experience"></div>
                            <div class="px-4" style="border-bottom: 1px solid #262626;">
                                <canvas data-op="chart" class="w-full"></canvas>
                            </div>
                            <div class="overflow-y-auto" style="max-height: 65vh;">
                                <div class="ui grid !m-0" data-op="content"></div>
                            </div>
                        </div>
                    `;
                }

                _createBindings () {
                    this.$experience = this.$parent.operator('experience');
                    this.$content = this.$parent.operator('content');

                    this.chart = new Chart(this.$parent.operator('chart'), {
                        type:'line',data:{datasets:[{fill:!1,borderWidth:1.5,data:[]}]},options:{title:{display:!0},legend:{display:!1},scales:{yAxes:[{gridLines:{color:'#2e2e2e',zeroLineColor:'#2e2e2e'},display:!0,ticks:{min:0,max:100,padding:10,stepSize:20,display:!1}}],xAxes:[{display:!1}]},tooltips:{enabled:!1},animation:{duration:0},events:[],hover:{animationDuration:0,},showTooltips:!1,responsiveAnimationDuration:0,elements:{line:{borderColor:'white',tension:0},point:{radius:0}}}
                    });

                    this.$screenshot = this.$parent.operator('screenshot');
                    this.$screenshot.click(() => {
                        const $contentParent = this.$content.parent();
                        $contentParent.css('max-height', '');
                        $contentParent.css('color', 'black');
                        $contentParent.find('.dungeon-shadow').css('color', 'purple');

                        html2canvas(this.$content.get(0), {
                            logging: false,
                            onclone: () => {
                                $contentParent.css('max-height', '65vh');
                                $contentParent.css('color', '');
                                $contentParent.find('.dungeon-shadow').css('color', '');
                            }
                        }).then((canvas) => {
                            canvas.toBlob((blob) => {
                                window.download(`dungeons_${Date.now()}.png`, blob);
                            });
                        });
                    });
                }

                _applyArguments (entries, experience, renderChart) {
                    // Display total experience
                    this.$experience.html(
                        experience ? `<div>${intl('dungeons.experience', { experience: formatAsSpacedNumber(experience, ' ') })}</div>` : ''
                    )

                    // Display all entries
                    this.$content.html(entries.map(({ boss, dungeon, score, healths, iterations }, index) => {
                        return `
                            <div class="row" data-id="${index}" style="padding: 0; padding-left: 8px;">
                                <div class="eleven wide column" style="position: relative; padding-top: 1rem; padding-bottom: 1rem;">
                                    <span class="${dungeon.shadow ? 'dungeon-shadow' : ''}"">
                                        <img class="ui centered image boss-image" style="position: absolute; left: 0; height: 2.5em; top: 0.5em; width: 2.5em;" src="res/class${ boss.class }.png">&nbsp;
                                        <span style="position: absolute; left: 3.75em; top: 0.4em; font-size: 80%;">${dungeon.name}</span>
                                        <span style="position: absolute; left: 3em; top: 1.4em;">#${boss.pos} - ${boss.name}</span>
                                    </span>
                                </div>
                                <div class="five wide column text-center" style="padding-top: 1rem; padding-bottom: 1rem;">${score == 0 ? intl('pets.bulk.not_possible') : `${ (100 * score / iterations).toFixed(2) }%`}</div>
                            </div>
                        `;
                    }).join(''));

                    // Attach hover listeners
                    this.$content.find('.row').mouseenter((event) => {
                        const { boss, dungeon, score, healths, iterations } = entries[event.currentTarget.dataset.id];

                        renderChart(this.chart, dungeon, boss, score, iterations, healths);
                    }).first().trigger('mouseenter');
                }
            })()

            Site.ready({ type: 'simulator' }, function (urlParams) {
                $('#cheat-menu-toggle').click(() => {
                    $('#cheat-menu').transition('fade left');
                    $('#cheat-menu-toggle .icon').toggleClass('left right');
                });
                $('#cheat-menu .checkbox').checkbox('set unchecked');

                for (let dungeon of Object.values(DUNGEON_DATA)) {
                    dungeon.name = intl(`dungeon_enemies.${dungeon.intl}.name`);

                    for (let enemy of Object.values(dungeon.floors)) {
                        enemy.name = intl(`dungeon_enemies.${dungeon.intl}.${enemy.pos}`);
                    }
                }

                let ignoreChanges = false;
                function withoutUpdate (func) {
                    ignoreChanges = true;
                    func();
                    ignoreChanges = false;
                }

                $('#sim-threads').captiveInputField('dungeon_sim/threads', 4, v => !isNaN(v) && v >= 1);
                $('#sim-iterations').captiveInputField('dungeon_sim/iterations', 5000, v => !isNaN(v) && v >= 1);

                $('#sim-run-next').contextmenu((e) => {
                    e.preventDefault();

                    DialogController.open(
                        SIMULATOR_THRESHOLD_DIALOG,
                        Store.shared.get('dungeon_sim/threshold', 5, true),
                        Store.shared.get('dungeon_sim/threshold_max', 100, true),
                        (min, max) => {
                            Store.shared.set('dungeon_sim/threshold', min, true)
                            Store.shared.set('dungeon_sim/threshold_max', max, true)
                        }
                    );
                });

                const HELPER_NAMES = [
                    intl('dungeons.player'),
                    intl('general.companion1'),
                    intl('general.companion2'),
                    intl('general.companion3')
                ]

                let editor = new (class extends Editor {
                    constructor ($parent, callback) {
                        super($parent, callback);

                        this.fields['name'].editable(false);
                    }

                    fill (object, index = 0) {
                        this.pauseListener();

                        super.fill(object);

                        if (index > 0) {
                            this.fields['class'].set(index);
                        }

                        this.morph.show(index == 0);

                        this.fields['class'].toggle(index == 0);
                        this.fields['gladiator'].toggle(index == 0);
                        this.fields['portal_hp'].toggle(index == 0);
                        this.fields['portal_damage'].toggle(index == 0);
                        this.fields['potion_life'].toggle(index == 0);
                        this.fields['level'].toggle(index == 0);
                        this.fields['shield'].show(object.Class == 1 && index == 0);
                        this.fields['name'].set(HELPER_NAMES[index]);

                        this.resumeListener();
                    }

                    _morph (newClass) {
                        super._morph(newClass);

                        saveEditor();
                        settingsChanged();
                    }
                })($('#sim-editor'), () => {
                    saveEditor();
                    settingsChanged();
                });

                // On paste event handler
                var players = [ editor.empty(1), editor.empty(1), editor.empty(2), editor.empty(3) ];

                var boss_current = null;
                var boss = null;
                var dungeon_current = null;
                var dungeon = null;
                var availableBosses = null;

                SimulatorUtils.configure({
                    params: urlParams,
                    onCopy: () => {
                        return players.map((p) => {
                            let m = toSimulatorModel(p);
                            if (p.Class == 1 && typeof p.BlockChance != 'undefined') {
                                m.BlockChance = p.BlockChance;
                            }

                            return m;
                        });
                    },
                    onLog: (callback) => {
                        executeSimulation(1, 50, callback);
                    }
                });

                function settingsChanged () {
                    $('#winchart').addClass('faded-out');
                }

                function getBossRunes (runes) {
                    let values = [0, 0, 0];

                    if (runes && runes.res) {
                        if (Array.isArray(runes.res)) {
                            values = runes.res;
                        } else {
                            values[runes.type - 40] = runes.res;
                        }
                    }

                    return {
                        Health: 0,
                        ResistanceFire: values[0],
                        ResistanceCold: values[1],
                        ResistanceLightning: values[2]
                    }
                }

                function getBossData (data, dungeon) {
                    return {
                        Armor: data.armor || ((dungeon.armor_multiplier || 1) * (data.level * CONFIG.fromIndex(data.class).MaximumDamageReduction)),
                        Class: data.class,
                        Name: data.name,
                        Level: data.level,
                        Health: data.health,
                        NoBaseDamage: true,
                        Identifier: 999,
                        Strength: { Total: data.str },
                        Dexterity: { Total: data.dex },
                        Intelligence: { Total: data.int },
                        Constitution: { Total: data.con },
                        Luck: { Total: data.lck },
                        Dungeons: { Player: 0, Group: 0 },
                        Fortress: { Gladiator: data.gladiator || 0 },
                        Potions: { Life: 0 },
                        Runes: getBossRunes(data.runes),
                        Items: {
                            Hand: {},
                            Wpn1: {
                                AttributeTypes: { 2: data.runes ? data.runes.type : 0 },
                                Attributes: { 2: data.runes ? data.runes.damage : 0 },
                                DamageMax: data.max,
                                DamageMin: data.min,
                                HasEnchantment: false
                            },
                            Wpn2: {
                                AttributeTypes: { 2: data.runes ? data.runes.type : 0 },
                                Attributes: { 2: data.runes ? data.runes.damage : 0 },
                                DamageMax: data.max,
                                DamageMin: data.min,
                                HasEnchantment: false
                            }
                        }
                    };
                }

                function getDisplayRunes (runes) {
                    if (runes) {
                        let displayType = ['F', 'C', 'L'][ runes.type - 40 ];

                        let displayDamage = `${runes.damage} ${displayType}`;

                        let displayResistance = '';
                        if (Array.isArray(runes.res)) {
                            displayResistance = ` / ${['F', 'C', 'L'].map((type, index) => `${runes.res[index]} ${type}`).join('&nbsp; ')}`;
                        } else if (runes.res) {
                            displayResistance = ` / ${runes.res} ${displayType}`;
                        }

                        return `<span class="boss-rune">${displayDamage}${displayResistance}</span>`;
                    } else {
                        return '';
                    }
                }

                $('#dungeon-list').dropdown({
                    values: _sort_asc(Object.values(DUNGEON_DATA), ({ pos }) => pos).map(({ name, shadow, floors, id: value }) => {
                        return {
                            name: shadow ? `<span class="dungeon-shadow">${name}<span>` : name,
                            value,
                            disabled: Object.keys(floors).length == 0
                        };
                    })
                }).dropdown('setting', 'onChange', (value, text) => {
                    dungeon_current = value;
                    dungeon = DUNGEON_DATA[value];

                    $('#boss-list').dropdown({
                        values: Object.entries(dungeon.floors).map(([ id, _boss ]) => {
                            return {
                                name: `<span class="${ dungeon.shadow ? 'dungeon-shadow' : '' }"">
                                           <img class="ui centered image boss-image" style="position: absolute; right: 0; height: 2.5em; top: 0; width: 2.5em;" src="res/class${ _boss.class }.png">
                                           ${ _boss.pos }. ${ _boss.name }
                                           ${ getDisplayRunes(_boss.runes) }
                                       <span>`,
                                value: id
                            };
                        })
                    }).dropdown('setting', 'onChange', (value, text) => {
                        if (!ignoreChanges) {
                            $('#available-list').dropdown('clear');
                        }

                        settingsChanged();

                        dungeon = DUNGEON_DATA[dungeon_current];
                        boss = dungeon.floors[value];
                        boss_current = boss;
                    }).dropdown('set selected', Object.keys(dungeon.floors)[0]);
                    show();
                }).dropdown('set selected', '1');

                var selected = 0;

                $(document.body).on('paste', function (event) {
                    if (event.target.type != 'text') {
                        try {
                            showData(SimulatorUtils.handlePaste(JSON.parse(event.originalEvent.clipboardData.getData('text'))));
                        } catch (e) {
                            // Do nothing
                        }
                    }
                });

                $('#sim-editor input').on('paste', function (event) { event.stopPropagation(); });

                function loadEditor (data) {
                    SFItem.forceCorrectRune(data.Items.Wpn1);
                    SFItem.forceCorrectRune(data.Items.Wpn2);

                    if (data.Class == 1 && typeof data.BlockChance == 'undefined') data.BlockChance = data.Items.Wpn2.DamageMin;
                    if (data.Class != 4) data.Items.Wpn2 = SFItem.empty();

                    if (selected > 0) {
                        for (var key of ['gladiator', 'level', 'portal_hp', 'portal_damage', 'potion_life']) {
                            var path = editor.fields[key].path();
                            setObjectAt(data, path, getObjectAt(players[0], path));
                        }
                    }

                    editor.fill(data, selected);
                }

                function saveEditor () {
                    if (editor.valid()) {
                        var obj = editor.read();
                        if (selected == 0) {
                            for (var key of ['gladiator', 'level', 'portal_hp', 'portal_damage', 'potion_life']) {
                                var path = editor.fields[key].path();

                                setObjectAt(players[1], path, getObjectAt(obj, path));
                                setObjectAt(players[2], path, getObjectAt(obj, path));
                                setObjectAt(players[3], path, getObjectAt(obj, path));
                            }
                        }

                        players[selected] = obj;
                    }
                }

                // Show fighters
                function show () {
                    var content1 = '';

                    for (var i = 0; i < 4; i++) {
                        content1 += `
                            <div class="row selectable ${ selected == i ? 'selected' : 'nselected' }" data-index="${ i }">
                                <div class="four wide text-center column">
                                    <img class="ui medium centered image" style="width: 50px; opacity: 75%;" src="res/portrait${ i ? i : '' }.png">
                                </div>
                                <div class="eight wide column text-center">
                                    <b>${HELPER_NAMES[i]}</b>
                                </div>
                                <div class="four wide column"></div>
                            </div>
                        `;
                    }

                    $('#sim-players1').html(content1);

                    $('[data-index]').click(function () {
                        select(Number($(this).attr('data-index')));
                    });
                }

                function select (index) {
                    selected = index;

                    editor.fill(players[selected], selected);
                    show();
                }

                select(0);

                const chart = new Chart($('#winchart'), {
                    type:'line',data:{datasets:[{fill:!1,borderWidth:1.5,data:[]}]},options:{title:{display:!0},legend:{display:!1},scales:{yAxes:[{gridLines:{color:'#2e2e2e',zeroLineColor:'#2e2e2e'},display:!0,ticks:{min:0,max:100,padding:10,stepSize:20,callback:function(value,index,values){return `${ value }%`}}}],xAxes:[{display:!1}]},tooltips:{enabled:!1},animation:{duration:0},events:[],hover:{animationDuration:0,},showTooltips:!1,responsiveAnimationDuration:0,elements:{line:{borderColor:'white',tension:0},point:{radius:0}}}
                });

                function showData (data) {
                    let oldSelected = selected;
                    if (Array.isArray(data)) {
                        for (let i = 0; i < 4; i++) {
                            selected = i;
                            loadEditor(data[i]);
                            saveEditor();
                        }

                        selected = oldSelected;
                        loadEditor(data[selected]);

                        show();
                    } else if (data.Class) {
                        loadEditor(data);
                        saveEditor();
                    }

                    settingsChanged();
                }

                const DUNGEON_ARR_TO_DID = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ];

                function getDungeonEnemyAt (dungeon, isShadow, enemyIndex) {
                    if (enemyIndex < 0) {
                        return null;
                    } else {
                        let id = dungeon + (isShadow ? 100 : 0);
                        let dung = DUNGEON_DATA[id];
                        let boss = Object.entries(dung.floors)[enemyIndex];
                        if (boss) {
                            return {
                                dungeon: dung,
                                boss: boss[1]
                            };
                        } else {
                            return null;
                        }
                    }
                }

                function getSpecialDungeonEnemyAt (dungeon, enemyIndex, soft = false) {
                    if (enemyIndex < 0) {
                        return null;
                    } else {
                        let floors = DUNGEON_DATA[dungeon].floors;
                        let boss = null;
                        if (soft) {
                            boss = Object.entries(floors).find(x => x[1].pos == enemyIndex);
                        } else {
                            boss = Object.entries(floors)[enemyIndex];
                        }

                        if (boss) {
                            return {
                                dungeon: DUNGEON_DATA[dungeon],
                                boss: boss[1]
                            }
                        } else {
                            return null;
                        }
                    }
                }

                let cheatsEnabled = false;
                let cheatsWasEnabled = false;

                $('#cheats-enabled').closest('.checkbox').change((el) => {
                    cheatsEnabled = el.target.checked;
                    if (cheatsEnabled) {
                        cheatsWasEnabled = true;
                    }
                });

                StatisticsIntegration.configure({
                    profile: SELF_PROFILE,
                    type: 'players',
                    scope: (dm) => dm.getLatestPlayers(),
                    callback: (player) => {
                        dungeon = DUNGEON_DATA[dungeon_current];
                        boss = boss_current;

                        if (cheatsWasEnabled) {
                            DatabaseManager._addPlayer(player.Data);
                            player = DatabaseManager.getPlayer(player.Identifier, player.Timestamp);

                            cheatsWasEnabled = false;
                        }

                        if (cheatsEnabled) {
                            applyCheats(player);

                            cheatsWasEnabled = true;
                        }

                        showData(player.toSimulatorShadowModel());

                        let normalDungeons = player.Dungeons.Normal;
                        let shadowDungeons = player.Dungeons.Shadow;
                        let tower = player.Dungeons.Tower;
                        let youtube = player.Dungeons.Youtube;
                        let twister = player.Dungeons.Twister + 1;

                        availableBosses = [
                            ... normalDungeons.map((dungeon, index) => getDungeonEnemyAt(DUNGEON_ARR_TO_DID[index], false, dungeon)),
                            getSpecialDungeonEnemyAt(201, player.Dungeons.Normal.Total < 90 ? -1 : tower),
                            getSpecialDungeonEnemyAt(203, twister, true),
                            ... shadowDungeons.map((dungeon, index) => getDungeonEnemyAt(DUNGEON_ARR_TO_DID[index], true, dungeon)),
                            getSpecialDungeonEnemyAt(202, youtube),
                        ].filter(boss => boss);

                        if (availableBosses.length) {
                            $('#available-list').parent('.field').removeClass('disabled');
                            $('#sim-run-all, #sim-run-next').removeClass('disabled');
                            $('#available-list').dropdown({
                                values: _sort_asc(availableBosses, ({ dungeon: _dungeon }) => _dungeon.pos).map(({ dungeon: _dungeon, boss: _boss }, index) => {
                                    return {
                                        name: `<span class="${_dungeon.shadow ? 'dungeon-shadow' : ''}">
                                                    <img class="ui centered image boss-image" style="position: absolute; right: 0; height: 2.5em; top: 0; width: 2.5em;" src="res/class${ _boss.class }.png">&nbsp;
                                                        <span class="boss-dungeon-name">${ _dungeon.name }</span>
                                                        <span class="boss-name">${ _boss.pos }. ${ _boss.name }</span>
                                                        ${ getDisplayRunes(_boss.runes) }
                                                <span>`,
                                        value: index
                                    };
                                })
                            }).dropdown('setting', 'onChange', (value, text) => {
                                if (!isNaN(value) && value && value.length > 0) {
                                    settingsChanged();

                                    let sel = availableBosses[value];

                                    dungeon = sel.dungeon;
                                    boss = sel.boss;

                                    withoutUpdate(() => {
                                        $('#dungeon-list').dropdown('set selected', sel.dungeon.id);
                                        $('#boss-list').dropdown('set selected', sel.boss.pos);
                                    });
                                }
                            });
                        } else {
                            $('#available-list').parent('.field').addClass('disabled');
                            $('#sim-run-all, #sim-run-next').addClass('disabled');
                        }
                    }
                })

                function showMassDungeonResults (bosses, results, sort, calculateTotalExperience) {
                    let entries = bosses.map((dungeon, index) => {
                        let result = _dig(results, index);
                        if (result) {
                            return Object.assign(result, dungeon);
                        } else {
                            return false;
                        }
                    }).filter(v => v);

                    if (sort === 'extended') {
                        let sortedBosses = [];
                        for (let entry of entries) {
                            let { score, boss, dungeon } = entry;

                            let lowerChanceIndex = sortedBosses.findIndex(({ score: _score }) => _score < score);
                            let index = sortedBosses.length;

                            if (lowerChanceIndex != -1) {
                                let sameDungeonIndex = sortedBosses.findLastIndex(({ dungeon: _dungeon, boss: _boss }) => (dungeon.id in NEXT_DUNGEONS_INVERTED) ? ((_dungeon.id === dungeon.id && _boss.pos < boss.pos) || (_dungeon.id === NEXT_DUNGEONS_INVERTED[dungeon.id])) : (_dungeon.id === dungeon.id && _boss.pos < boss.pos));
                                if (sameDungeonIndex != -1) {
                                    index = Math.max(lowerChanceIndex, sameDungeonIndex + 1);
                                } else {
                                    index = lowerChanceIndex;
                                }
                            }

                            sortedBosses.splice(index, 0, entry);
                        }

                        entries = sortedBosses;
                    } else if (sort) {
                        entries.sort((b, a) => a.score - b.score);
                    }

                    let experienceTotal = 0;
                    if (calculateTotalExperience) {
                        experienceTotal = _mapped_sum(entries, ({ boss, dungeon }) => {
                            if (dungeon.id === 201) {
                                return 0;
                            } else if (boss.level >= 393) {
                                return 3E8;
                            } else {
                                return EXPERIENCE_REQUIRED[boss.level] / 5;
                            }
                        }, 0);
                    }

                    DialogController.open(
                        SIMULATOR_RESULTS_DIALOG,
                        entries,
                        experienceTotal,
                        showGraph
                    );
                }

                function preparePlayerInstances (dungeon) {
                    let playerInstances = players.map(p => JSON.parse(JSON.stringify(p)));

                    if (dungeon.shadow) {
                        let bert = playerInstances[1];

                        let hp_a = (100 + bert.Dungeons.Player) / 100;
                        let hp_b = (100 + bert.Potions.Life) / 100;
                        let hp_c = (100 + bert.Runes.Health) / 100;
                        let hp_d = 1.22;

                        playerInstances[1].BlockChance = 0;
                        playerInstances[1].Health = Math.trunc(Math.floor(bert.Constitution.Total * 5 * (bert.Level + 1) * hp_a) * hp_b * hp_c * hp_d);
                    }

                    return dungeon.shadow ? [ ... playerInstances.slice(1, 4), playerInstances[0] ] : [ playerInstances[0] ];
                }

                $('#sim-run-all').click(function () {
                    const instances = Math.max(1, Number($('#sim-threads').val()) || 4);
                    const iterations = Math.max(1, Number($('#sim-iterations').val()) || 5000);
                    
                    if (availableBosses && availableBosses.length > 0 && editor.valid()) {
                        const results = [];

                        const batch = new WorkerBatch('dungeons');

                        for (let [index, { boss, dungeon }] of Object.entries(availableBosses)) {
                            batch.add(
                                ({ results: _results }) => {
                                    results[index] = _results;
                                },
                                {
                                    players: preparePlayerInstances(dungeon),
                                    boss: getBossData(boss, dungeon),
                                    iterations,
                                    hpcap: 500,
                                    config: SimulatorUtils.config
                                }
                            )
                        }

                        batch.run(instances).then(() => {
                            showMassDungeonResults(availableBosses, results, true, true);
                        })
                    }
                });

                const NEXT_DUNGEONS = {
                    13: 30,
                    113: 130,
                    14: 27,
                    114: 127,
                    16: 28,
                    116: 128,
                    17: 29,
                    117: 129
                };

                const NEXT_DUNGEONS_INVERTED = _invert(NEXT_DUNGEONS, true);

                $('#sim-run-next').click(function () {
                    const instances = Math.max(1, Number($('#sim-threads').val()) || 4);
                    const iterations = Math.max(1, Number($('#sim-iterations').val()) || 5000);
                   
                    const threshold_min = _clamp(Number(Store.shared.get('dungeon_sim/threshold', 5, true)), 0, 100);
                    const threshold_max = _clamp(Number(Store.shared.get('dungeon_sim/threshold_max', 5, true)), threshold_min, 100);
                    
                    if (availableBosses && availableBosses.length > 0 && editor.valid()) {
                        const results = [];
                        
                        let pending = [];
                        for (const { boss: _boss, dungeon: _dungeon } of availableBosses) {
                            if (_dungeon.id === 203) {
                                // Ignore twister
                                continue;
                            }

                            const dungeonStack = [];

                            for (const bossData of Object.values(_dungeon.floors)) {
                                if (dungeonStack.length > 0 || bossData.pos == _boss.pos) {
                                    dungeonStack.push({
                                        dungeon: _dungeon,
                                        boss: bossData
                                    })
                                }
                            }

                            if (_dungeon.id in NEXT_DUNGEONS) {
                                const nextId = NEXT_DUNGEONS[_dungeon.id];
                                const nextDungeon = DUNGEON_DATA[nextId];

                                for (const bossData of Object.values(nextDungeon.floors)) {
                                    dungeonStack.push({
                                        dungeon: nextDungeon,
                                        boss: bossData
                                    })
                                }
                            }

                            pending = pending.concat(dungeonStack);
                        }

                        const batch = new WorkerBatch('dungeons');

                        for (const [ index, { boss, dungeon } ] of Object.entries(pending)) {
                            batch.add(
                                ({ results: _results }) => {
                                    const score = _results.score;

                                    if (score < threshold_min * iterations / 100 || score > threshold_max * iterations / 100) {
                                        // If score is outside of the threshold, skip all remaining instances with same or next id
                                        batch.skip(({ id: _id }) => _id === dungeon.id || _id === NEXT_DUNGEONS[dungeon.id]);
                                    } else {
                                        results[index] = _results;
                                    }
                                },
                                {
                                    players: preparePlayerInstances(dungeon),
                                    boss: getBossData(boss, dungeon),
                                    iterations,
                                    hpcap: 500,
                                    config: SimulatorUtils.config,
                                    id: dungeon.id
                                }
                            )
                        }

                        batch.run(
                            instances,
                            // Execute instance only if there is none running with the same dungeon id
                            ({ id }, { id: _id }) => id !== _id && NEXT_DUNGEONS_INVERTED[id] !== _id
                        ).then(() => {
                            if (results.length > 0) {
                                showMassDungeonResults(pending, results, 'extended', true);
                            } else {
                                Toast.info(intl('dungeons.simulate_next_info.title', { threshold_min, threshold_max }), intl('dungeons.simulate_next_info.message#'));
                            }
                        })
                    }
                });

                $('#sim-run-dungeon').click(function () {
                    const instances = Math.max(1, Number($('#sim-threads').val()) || 4);
                    const iterations = Math.max(1, Number($('#sim-iterations').val()) || 5000);

                    if (editor.valid()) {
                        const results = [];
                        const bossQueue = [];

                        for (let bossData of Object.values(dungeon.floors)) {
                            if (bossQueue.length > 0 || bossData.pos == boss.pos) {
                                bossQueue.push({
                                    dungeon,
                                    boss: bossData
                                })
                            }
                        }

                        if (dungeon.id in NEXT_DUNGEONS) {
                            const nextId = NEXT_DUNGEONS[dungeon.id];
                            const nextDungeon = DUNGEON_DATA[nextId];

                            for (const bossData of Object.values(nextDungeon.floors)) {
                                bossQueue.push({
                                    dungeon: nextDungeon,
                                    boss: bossData
                                })
                            }
                        }

                        const batch = new WorkerBatch('dungeons');

                        for (let [index, { boss, dungeon }] of Object.entries(bossQueue)) {
                            batch.add(
                                ({ results: _results }) => {
                                    results[index] = _results
                                },
                                {
                                    players: preparePlayerInstances(dungeon),
                                    boss: getBossData(boss, dungeon),
                                    iterations,
                                    hpcap: 500,
                                    config: SimulatorUtils.config
                                }
                            )
                        }

                        batch.run(instances).then(() => {
                            showMassDungeonResults(bossQueue, results, false, true);
                        })
                    }
                })

                function executeSimulation (instances, iterations, logCallback) {
                    if (boss && editor.valid()) {
                        const bossInstance = getBossData(boss, dungeon);
                        const playerInstances = preparePlayerInstances(dungeon);

                        const results = [];
                        let logs = [];

                        let totalScore = 0;

                        const batch = new WorkerBatch('dungeons');

                        for (let i = 0; i < instances; i++) {
                            batch.add(
                                ({ results: { score, healths }, logs: _logs }) => {
                                    results.push(healths);
                                    logs = logs.concat(_logs);

                                    totalScore += score;
                                },
                                {
                                    players: playerInstances,
                                    boss: bossInstance,
                                    config: SimulatorUtils.config,
                                    log: !!logCallback,
                                    iterations
                                }
                            )
                        }

                        batch.run(instances).then(() => {
                            const finalResults = new Array(results[0].length);
                            for (let i = 0; i < results[0].length; i++) {
                                let healthsSum = 0;
                                for (let j = 0; j < instances; j++) {
                                    healthsSum += results[j][i];
                                }

                                finalResults[i] = healthsSum / instances;
                            }

                            showGraph(chart, dungeon, boss, totalScore, instances * iterations, _sort_asc(finalResults));
                            $('#winchart').removeClass('faded-out');

                            // Download logs
                            if (logs.length > 0) {
                                logCallback({
                                    fights: logs,
                                    players: [...playerInstances, bossInstance],
                                    config: SimulatorUtils.config
                                })
                            }
                        })
                    }
                }

                $('#sim-run').click(function () {
                    const instances = Math.max(1, Number($('#sim-threads').val()) || 4);
                    const iterations = Math.max(1, Number($('#sim-iterations').val()) || 5000);

                    executeSimulation(instances, iterations, false);
                });

                function showGraph (graph, dungeon, boss, score, tries, healths, showExperience = false) {
                    graph.options.title.text = [
                        `${ dungeon.id !== 201 && dungeon.shadow ? `${intl('dungeon_enemies.shadow')} ` : '' }${ dungeon.name }: ${ boss.name }`,
                        intl('dungeons.graph.winrate', { rate: (100 * score / tries).toFixed(2), score: formatAsSpacedNumber(score, ' '), tries: formatAsSpacedNumber(tries, ' ') })
                    ];

                    if (dungeon.id !== 201) {
                        let experience = boss.level >= 393 ? 3E8 : EXPERIENCE_REQUIRED[boss.level] / 5;
                        graph.options.title.text.splice(1, 0, `${formatAsSpacedNumber(experience, ' ')} XP`);
                    }

                    graph.data.datasets[0].data = healths.map((h, i) => { return { x: i, y: h * 100 }; });
                    graph.data.labels = healths.map((a, b) => b);
                    graph.update(0);
                }

                $('[data-cheat="class"]').dropdown({
                    preserveHTML: true,
                    values: [
                        {
                            name: intl('dungeons.cheats.keep_original'),
                            value: 0
                        },
                        ... CONFIG.indexes().map((e) => {
                            return {
                                name: `<img class="ui centered image !-ml-3 !mr-2" src="res/class${e}.png">${intl(`general.class${e}`)}`,
                                value: e
                            };
                        })
                    ]
                }).dropdown('set selected', '0');

                function applyCheat (player, callback) {
                    const models = [player];
                    if (player.Companions) {
                        models.push(...Object.values(player.Companions));
                    }

                    models.forEach(callback);
                }

                function applyCheats (player) {
                    let cheats = _array_to_hash($('[data-cheat]').toArray(), el => [el.dataset.cheat, el.tagName == 'DIV' ? parseInt($(el).dropdown('get value')) : el.checked]);

                    if (cheats.pets) {
                        applyCheat(player, (model) => {
                            model.Pets = {
                                Water: 40,
                                Light: 40,
                                Earth: 40,
                                Shadow: 40,
                                Fire: 40
                            };
                        });
                    }

                    if (cheats.enchantments) {
                        applyCheat(player, (model) => {
                            for (let item of Object.values(model.Items)) {
                                item.HasEnchantment = true;
                            };
                        });
                    }

                    // Set potions to player
                    const potions = _compact(['strength', 'dexterity', 'intelligence', 'constitution', 'luck', 'life'].map((type, i) => cheats[type] ? (i + 1) : null))
                    if (potions.length) {
                        applyCheat(player, (model) => {
                            const potionGroup = potions.slice(0, 3);

                            model.Potions = potionGroup.map(type => ({ Type: type, Size: 25 }));
                            model.Potions.Life = potionGroup.includes(6) ? 25 : 0;
                        });
                    }

                    if (cheats.class) {
                        const oldDefinition = CONFIG.fromIndex(player.Class);
                        const newDefinition = CONFIG.fromIndex(cheats.class);

                        const getAttributeList = function (attribute) {
                            return {
                                'Strength': ['Strength', 'Dexterity', 'Intelligence'],
                                'Dexterity': ['Dexterity', 'Strength', 'Intelligence'],
                                'Intelligence': ['Intelligence', 'Strength', 'Dexterity']
                            }[attribute]
                        }

                        const swapAttributes = function (obj) {
                            const oldattributes = getAttributeList(oldDefinition.Attribute).map((kind) => _dig(obj, kind)).map((att) => ({ Base: att.Base, Total: att.Total }));
                            const newAttributes = getAttributeList(newDefinition.Attribute);

                            for (let i = 0; i < 3; i++) {
                                for (const type of ['Base', 'Total']) {
                                    obj[newAttributes[i]][type] = oldattributes[i][type];
                                }
                            }
                        }

                        const scaleValue = function (value, oldValue, newValue) {
                            return Math.ceil(value / oldValue * newValue);
                        }

                        // Morph all items to desired class
                        const getAttributeID = (attribute) => {
                            return {
                                'Strength': 1,
                                'Dexterity': 2,
                                'Intelligence': 3
                            }[attribute]
                        }

                        for (const [type, item] of Object.entries(player.Items)) {
                            player.Items[type] = item.morph(getAttributeID(oldDefinition.Attribute), getAttributeID(newDefinition.Attribute), true);
                        }

                        // Swap attributes
                        swapAttributes(player);

                        // Scale damage & armor
                        player.Armor = scaleValue(player.Armor, oldDefinition.MaximumDamageReduction, newDefinition.MaximumDamageReduction);
                        player.Items.Wpn1.DamageMin = scaleValue(player.Items.Wpn1.DamageMin, oldDefinition.WeaponDamageMultiplier, newDefinition.WeaponDamageMultiplier);
                        player.Items.Wpn1.DamageMax = scaleValue(player.Items.Wpn1.DamageMax, oldDefinition.WeaponDamageMultiplier, newDefinition.WeaponDamageMultiplier);

                        // Set per-class data
                        if (cheats.class == WARRIOR) {
                            player.Items.Wpn2.DamageMin = 25;
                        } else if (cheats.class == ASSASSIN) {
                            player.Items.Wpn2 = player.Items.Wpn1;
                        }

                        player.Class = cheats.class;
                    }

                    if (potions.length > 0 || cheats.pets || cheats.class) {
                        applyCheat(player, (model) => {
                            // Remove pre-calculated bonus
                            for (let type of ['Strength', 'Dexterity', 'Intelligence', 'Constitution', 'Luck']) {
                                model[type].Bonus = undefined;
                            }

                            // Evaluate commons
                            if (model instanceof SFCompanion) {
                                model.evaluateCompanionCommon(player);
                            } else {
                                model.evaluateCommon();
                            }
                        });
                    }

                    if (cheats.runes) {
                        applyCheat(player, (model) => {
                            model.Runes.Health = 15;
                            model.Runes.ResistanceFire = 75;
                            model.Runes.ResistanceCold = 75;
                            model.Runes.ResistanceLightning = 75;
                            model.Items.Wpn1.Attributes[2] = 60;
                            model.Items.Wpn2.Attributes[2] = 60;
                        });
                    }
                }

                function convertBossToSimulatorFormat (rawData, rawDungeon) {
                    return _tap(getBossData(rawData, rawDungeon), function (data) {
                        const definition = CONFIG.fromIndex(data.Class);

                        const level = data.Level;
                        const health = data.Health;

                        data.Constitution.Total = Math.ceil(health / (definition.HealthMultiplier * (level + 1)));

                        if (typeof data.Armor === 'undefined') {
                            data.Armor = definition.MaximumDamageReduction * level * (rawDungeon.armor_multiplier || 1.0);
                        }

                        if (data.Class === WARRIOR) {
                            data.BlockChance = 25;
                        }
                    })
                }

                return {
                    currentBoss: () => convertBossToSimulatorFormat(boss, dungeon),
                    currentDungeon: () => Object.values(dungeon.floors).map(b => convertBossToSimulatorFormat(b, dungeon))
                };
            });
        </script>
    </body>
</html>
