<!DOCTYPE html>
<html lang="en">
    <head>
        <title>SFTools - Fight Analyzer</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/png" href="res/favicon.png"/>

        <link rel="stylesheet" href="css/pages/analyzer.css"/>

        <script src="vendor/js/jquery.3.4.1.min.js"></script>
        <script src="vendor/js/semantic.min.js"></script>
        <script src="vendor/js/sentry.bundle.min.js"></script>

        <script src="js/enum.js"></script>
        <script src="js/util.js"></script>
        <script src="js/lang.js"></script>

        <script src="js/core/util.js"></script>
        <script src="js/core/playa.js"></script>
        <script src="js/core/core.js"></script>
        <script src="js/plugins.js"></script>
        <script src="js/core/idb.js"></script>
        <script src="js/core/ast.js"></script>
        <script src="js/stats/settings.js"></script>        
        <script src="js/changelog.js"></script>
        <script src="js/views.js"></script>
        <script src="js/editor.js"></script>

        <script src="js/sim/dungeon_data.js"></script>

        <script src="js/sim/base.js"></script>
        <script src="js/sim/debug_utils.js"></script>
    </head>
    <body class="inverted">
        <div class="ui fixed inverted borderless huge menu" style="z-index: 3;">
            <div class="header item"><a href="index.html">SFTools</a></div>
            <label for="button-upload">
                <a class="item"><i class="upload icon"></i> <span data-intl="analyzer.topbar.import"></span></a>
            </label>
            <input type="file" accept=".har,.json" multiple class="ui invisible file input" id="button-upload">
            <a class="item" id="button-export"><i class="download icon"></i> <span data-intl="analyzer.topbar.export"></span></a>
            <a class="item" id="button-clear"><i class="recycle icon"></i> <span data-intl="analyzer.topbar.clear"></span></a>
        </div>

        <div class="ui main inverted container mb-20" style="width: 65vw;">
            <div class="ui small inverted form">
                <div class="two fields">
                    <div class="fifteen wide field">
                        <label data-intl="analyzer.form.fight_group"></label>
                        <div class="ui selection inverted dropdown" id="fight-group">
                            <div class="text"></div>
                            <i class="dropdown icon"></i>
                        </div>
                    </div>
                    <div class="one wide field" style="width: 8%;">
                        <label>&nbsp;</label>
                        <div class="ui right floated buttons">    
                            <div class="ui icon small basic inverted button" id="button-export-group" data-inverted="" data-position="bottom center" data-intl-tooltip="analyzer.export">
                                <i class="ui download icon"></i>
                            </div>
                            <div class="ui icon small basic inverted button" id="view-summary-group" data-inverted="" data-position="bottom center" data-intl-tooltip="analyzer.summary.view">
                                <i class="ui tasks icon"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="fight-view" class="!mt-6" style="display: none;">
                <h3 class="ui inverted centered header" data-intl="analyzer.players"></h3>
                <div class="ui two column grid">
                    <div class="column">
                        <div class="ui grey inverted segment">
                            <div class="ui small inverted form" id="player1">
                                <h4 class="ui centered inverted header" data-intl="analyzer.form.player1"></h4>
                                <div class="three fields">
                                    <div class="eight wide field">
                                        <label data-intl="editor.name"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Name">
                                        </div>
                                    </div>
                                    <div class="five wide field">
                                        <label data-intl="editor.class"></label>
                                        <div class="ui selection inverted dropdown pointer-events-none !text-center !pr-4" data-path="Class">
                                            <div class="text text-center"></div>
                                        </div>
                                    </div>
                                    <div class="four wide field">
                                        <label data-intl="editor.level"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Level">
                                        </div>
                                    </div>
                                </div>
                                <div class="five fields">
                                    <div class="field">
                                        <label data-intl="general.attribute1"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Strength.Total">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="general.attribute2"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Dexterity.Total">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="general.attribute3"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Intelligence.Total">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="general.attribute4"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Constitution.Total">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="general.attribute5"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Luck.Total">
                                        </div>
                                    </div>
                                </div>
                                <h4 class="ui centered inverted header" data-intl="analyzer.form.editable_data"></h4>
                                <div class="five fields">
                                    <div class="field">
                                        <label data-intl="editor.min"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn1.DamageMin" data-intl-placeholder="editor.min_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.max"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn1.DamageMax" data-intl-placeholder="editor.max_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.weapon_enchant"></label>
                                        <div class="ui selection inverted dropdown" data-path="Items.Wpn1.HasEnchantment">
                                            <div class="text"></div>
                                            <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.rune"></label>
                                        <div class="ui inverted centered input">
                                            <div class="ui selection inverted fluid dropdown" data-path="Items.Wpn1.AttributeTypes.2">
                                                <div class="text"></div>
                                                <i class="dropdown icon"></i>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label><br/></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn1.Attributes.2" placeholder="0 - 60">
                                        </div>
                                    </div>
                                </div>
                                <div class="five fields" data-optional="Weapon2">
                                    <div class="field">
                                        <label data-intl="editor.min"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn2.DamageMin" data-intl-placeholder="editor.min_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.max"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn2.DamageMax" data-intl-placeholder="editor.max_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.weapon_enchant"></label>
                                        <div class="ui selection inverted dropdown" data-path="Items.Wpn2.HasEnchantment">
                                            <div class="text"></div>
                                            <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.rune"></label>
                                        <div class="ui inverted centered input">
                                            <div class="ui selection inverted fluid dropdown" data-path="Items.Wpn2.AttributeTypes.2">
                                                <div class="text"></div>
                                                <i class="dropdown icon"></i>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label><br/></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn2.Attributes.2" placeholder="0 - 60">
                                        </div>
                                    </div>
                                </div>
                                <div class="four fields">
                                    <div class="field">
                                        <label data-intl="editor.armor"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Armor" data-intl-placeholder="editor.armor_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.fire"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Runes.ResistanceFire" placeholder="0 - 75">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.cold"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Runes.ResistanceCold" placeholder="0 - 75">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.lightning"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Runes.ResistanceLightning" placeholder="0 - 75">
                                        </div>
                                    </div>
                                </div>
                                <div class="two fields !mb-0">
                                    <div class="field">
                                        <label data-intl="editor.portal_damage"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Dungeons.Group" placeholder="0 - 50">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.gladiator"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Fortress.Gladiator" placeholder="0 - 15">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="column">
                        <div class="ui grey inverted segment">
                            <div class="ui small inverted form" id="player2">
                                <h4 class="ui centered inverted header" data-intl="analyzer.form.player2"></h4>
                                <div class="three fields">
                                    <div class="eight wide field">
                                        <label data-intl="editor.name"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Name">
                                        </div>
                                    </div>
                                    <div class="five wide field">
                                        <label data-intl="editor.class"></label>
                                        <div class="ui selection inverted dropdown pointer-events-none !text-center !pr-4" data-path="Class">
                                            <div class="text"></div>
                                        </div>
                                    </div>
                                    <div class="four wide field">
                                        <label data-intl="editor.level"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Level">
                                        </div>
                                    </div>
                                </div>
                                <div class="five fields">
                                    <div class="field">
                                        <label data-intl="general.attribute1"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Strength.Total">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="general.attribute2"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Dexterity.Total">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="general.attribute3"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Intelligence.Total">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="general.attribute4"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Constitution.Total">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="general.attribute5"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" disabled data-path="Luck.Total">
                                        </div>
                                    </div>
                                </div>
                                <h4 class="ui centered inverted header" data-intl="analyzer.form.editable_data"></h4>
                                <div class="five fields">
                                    <div class="field">
                                        <label data-intl="editor.min"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn1.DamageMin" data-intl-placeholder="editor.min_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.max"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn1.DamageMax" data-intl-placeholder="editor.max_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.weapon_enchant"></label>
                                        <div class="ui selection inverted dropdown" data-path="Items.Wpn1.HasEnchantment">
                                            <div class="text"></div>
                                            <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.rune"></label>
                                        <div class="ui inverted centered input">
                                            <div class="ui selection inverted fluid dropdown" data-path="Items.Wpn1.AttributeTypes.2">
                                                <div class="text"></div>
                                                <i class="dropdown icon"></i>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label><br/></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn1.Attributes.2" placeholder="0 - 60">
                                        </div>
                                    </div>
                                </div>
                                <div class="five fields" data-optional="Weapon2">
                                    <div class="field">
                                        <label data-intl="editor.min"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn2.DamageMin" data-intl-placeholder="editor.min_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.max"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn2.DamageMax" data-intl-placeholder="editor.max_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.weapon_enchant"></label>
                                        <div class="ui selection inverted dropdown" data-path="Items.Wpn2.HasEnchantment">
                                            <div class="text"></div>
                                            <i class="dropdown icon"></i>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.rune"></label>
                                        <div class="ui inverted centered input">
                                            <div class="ui selection inverted fluid dropdown" data-path="Items.Wpn2.AttributeTypes.2">
                                                <div class="text"></div>
                                                <i class="dropdown icon"></i>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label><br/></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Items.Wpn2.Attributes.2" placeholder="0 - 60">
                                        </div>
                                    </div>
                                </div>
                                <div class="four fields">
                                    <div class="field">
                                        <label data-intl="editor.armor"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Armor" data-intl-placeholder="editor.armor_placeholder">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.fire"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Runes.ResistanceFire" placeholder="0 - 75">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.cold"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Runes.ResistanceCold" placeholder="0 - 75">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.lightning"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Runes.ResistanceLightning" placeholder="0 - 75">
                                        </div>
                                    </div>
                                </div>
                                <div class="two fields !mb-0">
                                    <div class="field">
                                        <label data-intl="editor.portal_damage"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Dungeons.Group" placeholder="0 - 50">
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label data-intl="editor.gladiator"></label>
                                        <div class="ui inverted centered input">
                                            <input type="text" data-path="Fortress.Gladiator" placeholder="0 - 15">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <h3 class="ui inverted centered header" data-intl="analyzer.preview"></h3>
                <div class="ui small inverted form">
                    <div class="two fields">
                        <div class="fifteen wide field">
                            <label data-intl="analyzer.form.fight_list"></label>
                            <div class="ui selection inverted dropdown" id="fight-list">
                                <div class="text"></div>
                                <i class="dropdown icon"></i>
                            </div>
                        </div>
                        <div class="one wide field" style="width: 8%;">
                            <label>&nbsp;</label>
                            <div class="ui right floated buttons">
                                <div class="ui icon small basic inverted button" id="fight-copy" data-inverted="" data-position="bottom center" data-intl-tooltip="editor.copy">
                                    <i class="ui copy icon"></i>
                                </div>
                                <div class="ui icon small basic inverted button" id="view-summary-fight" data-inverted="" data-position="bottom center" data-intl-tooltip="analyzer.summary.view">
                                    <i class="ui tasks icon"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <table class="ui inverted single very line basic table fixed mt-8">
                    <thead>
                        <tr>
                            <th style="width: 5%;" class="!text-center">#</th>
                            <th style="width: 10%;" class="!text-center" data-intl="analyzer.table.rage"></th>
                            <th style="width: 15%;" class="!text-center" data-intl="analyzer.table.attacker"></th>
                            <th style="width: 15%;" class="!text-center" data-intl="analyzer.table.target"></th>
                            <th style="width: 15%;" class="!text-center" data-intl="analyzer.table.type"></th>
                            <th style="width: 15%;" class="!text-center" data-intl="analyzer.table.damage"></th>
                            <th style="width: 10%;" class="!text-center" data-intl="analyzer.table.health"></th>
                            <th style="width: 15%;" class="!text-center" data-intl="analyzer.table.damage_base"></th>
                        </tr>
                    </thead>
                    <tbody id="fight-table"></tbody>
                </table>
            </div>
        </div>

        <script type="text/javascript">
            const FightSummaryDialog = new (class extends Dialog {
                constructor () {
                    super({
                        key: 'shared',
                        dismissable: true,
                        opacity: 0
                    })
                }

                _createModal () {
                    return `
                        <div class="small bordered inverted dialog">
                            <div data-op="content"></div>
                            <button class="ui black fluid button" data-op="cancel">${this.intl('close')}</button>
                        </div>
                    `;
                }

                _createBindings () {
                    this.$closeButton = this.$parent.find('[data-op="cancel"]');
                    this.$closeButton.click(() => {
                        this.close();
                    })

                    this.$content = this.$parent.find('[data-op="content"]');
                }

                _applyArguments (group, { fighterA, fighterB }) {
                    let content = `
                        <h2 class="ui centered inverted header">${intl('analyzer.summary.damage')}</h2>
                        <table class="ui inverted single very line basic table fixed">
                            <thead>
                                <tr>
                                    <th style="width: 20%;" class="!text-center">${intl('analyzer.table.damage')}</th>
                                    <th style="width: 40%; text-overflow: ellipsis; white-space: nowrap;" class="!text-center">${group.fighterA.Name}</th>
                                    <th style="width: 40%; text-overflow: ellipsis; white-space: nowrap;" class="!text-center">${group.fighterB.Name}</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="!text-center">${intl('editor.min')}</td>
                                    <td class="!text-center">${formatAsSpacedNumber(fighterA.damage.min)}</td>
                                    <td class="!text-center">${formatAsSpacedNumber(fighterB.damage.min)}</td>
                                </tr>
                                <tr>
                                    <td class="!text-center">${intl('editor.max')}</td>
                                    <td class="!text-center">${formatAsSpacedNumber(fighterA.damage.max)}</td>
                                    <td class="!text-center">${formatAsSpacedNumber(fighterB.damage.max)}</td>
                                </tr>
                            </tbody>
                        </table>
                        <h2 class="ui centered inverted header">${intl('analyzer.summary.type')}</h2>
                        <table class="ui inverted single very line basic table fixed">
                            <thead>
                                <tr>
                                    <th style="width: 20%;" class="!text-center">${intl('analyzer.table.type')}</th>
                                    <th style="width: 40%; text-overflow: ellipsis; white-space: nowrap;" class="!text-center">${group.fighterA.Name}</th>
                                    <th style="width: 40%; text-overflow: ellipsis; white-space: nowrap;" class="!text-center">${group.fighterB.Name}</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    // Attacks
                    const keys = Object.keys(Object.assign({}, fighterA.attacks, fighterB.attacks));
                    for (const key of keys) {
                        content += `
                            <tr>
                                <td class="!text-center">${intl(`general.attack${key}`)}</td>
                                <td class="!text-center">${fighterA.attacks[key] || 0}</td>
                                <td class="!text-center">${fighterB.attacks[key] || 0}</td>
                            </tr>
                        `;
                    }

                    content += `
                            </tbody>
                        </table>
                    `;

                    this.$content.html(content);
                }
            })();

            Site.ready(null, function (urlParams) {
                // Elements
                const $buttonUpload = $('#button-upload');
                const $buttonClear = $('#button-clear');
                const $buttonExport = $('#button-export');
                const $buttonExportGroup = $('#button-export-group');

                const $fightGroup = $('#fight-group');
                const $fightList = $('#fight-list');
                const $fightTable = $('#fight-table');
                const $fightView = $('#fight-view');
                const $fightCopy = $('#fight-copy');

                const $viewSummaryGroup = $('#view-summary-group');
                const $viewSummaryFight = $('#view-summary-fight');

                // Button callbacks
                $buttonUpload.on('change', async (fileEvent) => {
                    Loader.toggle(true);

                    try {
                        await Promise.all(Array.from(fileEvent.currentTarget.files).map((file) => file.text().then((text) => {
                            const json = JSON.parse(text);
        
                            if (json.log) {
                                importHAR(json);
                            } else if (json.fights) {
                                importFights(json);
                            } else {
                                Toast.warn(intl('analyzer.toast_import_error.title'), intl('analyzer.toast_import_error.message'));
                            }
                        })));
                    } catch (e) {
                        console.info(e);
                        
                        Toast.warn(intl('analyzer.toast_import_error.title'), intl('analyzer.toast_import_error.message'));
                    }

                    render();

                    Loader.toggle(false);
                })

                $buttonClear.click(() => {
                    currentFights = [];
                    currentPlayers = [];

                    currentGroup = null;
                    currentFight = null;

                    render();
                })

                $buttonExport.click(() => {
                    if (currentFights.length > 0) {
                        exportFights(currentFights);
                    }
                })

                $buttonExportGroup.click(() => {
                    if (currentGroup) {
                        exportFights(currentGroup); 
                    }
                })

                $fightCopy.click(() => {
                    copyNode($fightTable.closest('table').get(0));
                });

                // Custom fighter
                class SFFighter {
                    constructor (data, fightType) {
                        let dataType = new ComplexDataType(data);
                        dataType.assert(47);

                        this.ID = dataType.long();
                        this.Name = dataType.string();
                        this.Level = dataType.long();
                        this.MaximumLife = dataType.long();
                        this.Life = dataType.long();

                        this.Strength = {
                            Total: dataType.long()
                        };

                        this.Dexterity = {
                            Total: dataType.long()
                        };

                        this.Intelligence = {
                            Total: dataType.long()
                        };

                        this.Constitution = {
                            Total: dataType.long()
                        };

                        this.Luck = {
                            Total: dataType.long()
                        };

                        this.Face = {
                            Mouth: dataType.long(),
                            Hair: {
                                Type: dataType.long() % 100,
                                Color: Math.trunc(dataType.back(1).long() / 100)
                            },
                            Brows: {
                                Type: dataType.long() % 100,
                                Color: Math.trunc(dataType.back(1).long() / 100)
                            },
                            Eyes: dataType.long(),
                            Beard: {
                                Type: dataType.long() % 100,
                                Color: Math.trunc(dataType.back(1).long() / 100)
                            },
                            Nose: dataType.long(),
                            Ears: dataType.long(),
                            Special: dataType.long(),
                            Special2: dataType.long(),
                            Portrait: dataType.long()
                        };

                        this.Race = dataType.long();
                        this.Gender = dataType.long();
                        this.Class = dataType.long();

                        this.Items = {
                            Wpn1: new SFItem(dataType.sub(12), 1, [1, 1]),
                            Wpn2: new SFItem(dataType.sub(12), 2, [1, 2])
                        }

                        if (this.Face.Mouth < 0) {
                            this.Name = getFightTargetName(fightType, null, -this.Face.Mouth);
                        }
                    }
                }

                // Editor
                class PlayerEditor {
                    constructor (parent) {
                        this.fields = {
                            name: new Field(`${parent} [data-path="Name"]`, ''),

                            class: new Field(`${parent} [data-path="Class"]`, '1'),
                            level: new Field(`${parent} [data-path="Level"]`, '0', Field.isPlayerLevel),
                            armor: new Field(`${parent} [data-path="Armor"]`, '0', Field.isNumber),

                            resistance_fire: new Field(`${parent} [data-path="Runes.ResistanceFire"]`, '0', Field.isResistanceRune),
                            resistance_cold: new Field(`${parent} [data-path="Runes.ResistanceCold"]`, '0', Field.isResistanceRune),
                            resistance_lightning: new Field(`${parent} [data-path="Runes.ResistanceLightning"]`, '0', Field.isResistanceRune),

                            portal_damage: new Field(`${parent} [data-path="Dungeons.Group"]`, '0', Field.isDungeon),

                            gladiator: new Field(`${parent} [data-path="Fortress.Gladiator"]`, '0', Field.isUnderworldBuilding),

                            str: new Field(`${parent} [data-path="Strength.Total"]`, '0', Field.isNonZero),
                            dex: new Field(`${parent} [data-path="Dexterity.Total"]`, '0', Field.isNonZero),
                            int: new Field(`${parent} [data-path="Intelligence.Total"]`, '0', Field.isNonZero),
                            con: new Field(`${parent} [data-path="Constitution.Total"]`, '0', Field.isNonZero),
                            lck: new Field(`${parent} [data-path="Luck.Total"]`, '0', Field.isNumber),

                            weapon1_min: new Field(`${parent} [data-path="Items.Wpn1.DamageMin"]`, '0', Field.isNumber),
                            weapon1_max: new Field(`${parent} [data-path="Items.Wpn1.DamageMax"]`, '0', Field.isNumber),
                            weapon1_enchantment: new Field(`${parent} [data-path="Items.Wpn1.HasEnchantment"]`, 'false'),
                            weapon1_rune: new Field(`${parent} [data-path="Items.Wpn1.AttributeTypes.2"]`, '0'),
                            weapon1_value: new Field(`${parent} [data-path="Items.Wpn1.Attributes.2"]`, '0', Field.isDamageRune),

                            weapon2_min: new Field(`${parent} [data-path="Items.Wpn2.DamageMin"]`, '0', Field.isNumber),
                            weapon2_max: new Field(`${parent} [data-path="Items.Wpn2.DamageMax"]`, '0', Field.isNumber),
                            weapon2_enchantment: new Field(`${parent} [data-path="Items.Wpn2.HasEnchantment"]`, 'false'),
                            weapon2_rune: new Field(`${parent} [data-path="Items.Wpn2.AttributeTypes.2"]`, '0'),
                            weapon2_value: new Field(`${parent} [data-path="Items.Wpn2.Attributes.2"]`, '0', Field.isDamageRune)
                        };

                        this.fields['class'].$object.dropdown({
                            values: CONFIG.indexes().map((value) => ({
                                image: `res/class${value}.png`,
                                imageClass: '!-ml-3 !mr-2',
                                name: intl(`general.class${value}`),
                                value
                            }))
                        }).dropdown('setting', 'onChange', (value) => {
                            $(`${parent} [data-optional="Weapon2"]`).toggle(value == ASSASSIN);
                        }).dropdown('set selected', '1');

                        this.fields['weapon1_rune'].$object.dropdown({
                            values: [
                                {
                                    name: intl('editor.none'),
                                    value: 0
                                },
                                {
                                    name: intl('editor.fire'),
                                    value: 40
                                },
                                {
                                    name: intl('editor.cold'),
                                    value: 41
                                },
                                {
                                    name: intl('editor.lightning'),
                                    value: 42
                                }
                            ]
                        }).dropdown('set selected', '0');

                        this.fields['weapon2_rune'].$object.dropdown({
                            values: [
                                {
                                    name: intl('editor.none'),
                                    value: 0
                                },
                                {
                                    name: intl('editor.fire'),
                                    value: 40
                                },
                                {
                                    name: intl('editor.cold'),
                                    value: 41
                                },
                                {
                                    name: intl('editor.lightning'),
                                    value: 42
                                }
                            ]
                        }).dropdown('set selected', '0');

                        this.fields['weapon1_enchantment'].$object.dropdown({
                            values: [
                                {
                                    name: intl('general.no'),
                                    value: false
                                },
                                {
                                    name: intl('general.yes'),
                                    value: true
                                }
                            ]
                        }).dropdown('set selected', 'false');

                        this.fields['weapon2_enchantment'].$object.dropdown({
                            values: [
                                {
                                    name: intl('general.no'),
                                    value: false
                                },
                                {
                                    name: intl('general.yes'),
                                    value: true
                                }
                            ]
                        }).dropdown('set selected', 'false');

                        for (const field of Object.values(this.fields)) {
                            field.setListener(() => {
                                if (!this._frozen) {
                                    updatePreview();
                                }
                            });
                        }
                    }

                    fill (object) {
                        this._frozen = true;

                        for (const [key, field] of Object.entries(this.fields)) {
                            const value = getObjectAt(object, field.path());
                            if (typeof value === 'undefined') {
                                field.clear();
                            } else {
                                field.set(value);
                            }
                        }

                        this._frozen = false;
                    }

                    read () {
                        const object = {};
                        for (const [key, field] of Object.entries(this.fields)) {
                            setObjectAt(object, field.path(), field.get());
                        }

                        return object;
                    }

                    valid () {
                        for (const [key, field] of Object.entries(this.fields)) {
                            if (!field.valid()) {
                                return false;
                            }
                        }

                        return true;
                    }
                }

                const playerEditorA = new PlayerEditor('#player1');
                const playerEditorB = new PlayerEditor('#player2');

                // Utils
                SimulatorUtils.configure({
                    params: urlParams
                });

                // Decode attack type
                function decodeAttackType (attackType) {
                    if (attackType >= ATTACK_REVIVE) {
                        return {
                            attackSecondary: false,
                            attackCrit: false,
                            attackMissed: false,
                            attackSpecial: true
                        }
                    } else {
                        const attackSecondary = ATTACKS_SECONDARY.includes(attackType);
                        const attackChained = ATTACKS_CHAIN.includes(attackType);
                        
                        const attackCrit = [
                            ATTACK_CRITICAL,
                            ATTACK_CRITICAL_BLOCKED,
                            ATTACK_CRITICAL_EVADED
                        ].includes(attackType % 10);

                        const attackMissed = [
                            ATTACK_BLOCKED,
                            ATTACK_EVADED,
                            ATTACK_CRITICAL_BLOCKED,
                            ATTACK_CRITICAL_EVADED
                        ].includes(attackType % 10);

                        return {
                            attackSecondary,
                            attackCrit,
                            attackMissed,
                            attackChained,
                            attackSpecial: false
                        }
                    }
                }

                // Compute item hash
                function computeItemHash (item, player, secondary = false) {
                    if (secondary && player.Class !== ASSASSIN) {
                        return '';
                    } else if (item.Index == 0) {
                        return '';
                    } else {
                        const json = [
                            item.DamageMin,
                            item.DamageMax,
                            item.RuneType || item.AttributeTypes[2],
                            item.RuneValue || item.Attributes[2]
                        ]

                        if (player.model) {
                            // Fix weapon damage (is not clamped by fist damage)
                            const baseDamage = player.model.getBaseDamage(secondary);

                            json[0] = Math.max(baseDamage.Min, json[0]);
                            json[1] = Math.max(baseDamage.Max, json[1]);
                        }

                        return JSON.stringify(json);
                    }
                }

                // Compute player hash
                function computePlayerHash (player) {
                    const json = [
                        // Temporary disabled because of HASH errors // player.ID,
                        player.Class,
                        player.Level,
                        player.Strength.Total,
                        player.Dexterity.Total,
                        player.Intelligence.Total,
                        player.Constitution.Total,
                        player.Luck.Total,
                        computeItemHash(player.Items.Wpn1, player, false),
                        computeItemHash(player.Items.Wpn2, player, true)
                    ];

                    return JSON.stringify(json);
                }

                // Extract individual fights from raw data array
                function importHAR (json) {
                    const digestedFights = [];
                    const digestedPlayers = [];

                    // Capture all relevant data
                    for (const { text } of PlayaResponse.search(json)) {
                        if (text.includes('fightheader')) {
                            const r = PlayaResponse.fromText(text);

                            if (r.fightheader1) {
                                // Shadow or guild fights use indexed fight data
                                const count = _fast_max(
                                    Object.keys(r)
                                    .filter((key) => key.startsWith('fightheader'))
                                    .map((key) => parseInt(key.match(/(\d*)$/)[0] || '1'))
                                );

                                for (let i = 1; i <= count; i++) {
                                    digestedFights.push({
                                        header: r[`fightheader${i}`].mixed,
                                        rounds: r[`fight${i}`].numbers
                                    });
                                }
                            } else {
                                digestedFights.push({
                                    header: r.fightheader.mixed,
                                    rounds: r.fight.numbers
                                });
                            }
                        }
                        
                        if (text.includes('playerlookat') || text.includes('ownplayersave')) {
                            const r = PlayaResponse.fromText(text);

                            if (r.ownplayersave && r.ownplayername) {
                                // Read only necessary data from own player
                                digestedPlayers.push({
                                    own: true,
                                    save: r.ownplayersave.numbers,
                                    name: r.ownplayername.string,
                                    tower: _try(r.owntower, 'numbers')
                                })
                            } else if (r.ownplayersave) {
                                // Capture save
                                const lastPlayer = digestedPlayers.findLast((entry) => entry.own && entry.name);
                                if (lastPlayer) {
                                    digestedPlayers.push({
                                        own: true,
                                        save: r.ownplayersave.numbers,
                                        name: lastPlayer.name,
                                        tower: _try(r.owntower, 'numbers') || lastPlayer.tower
                                    })
                                }
                            } else if (r['#ownplayersave']) {
                                // Capture save delta
                                const lastPlayer = digestedPlayers.findLast((entry) => entry.own && entry.name);
                                if (lastPlayer) {
                                    const save = Array.from(lastPlayer.save);

                                    for (const [index, value] of _each_block(r['#ownplayersave'].numbers, 2)) {
                                        save[index] = value;
                                    }

                                    digestedPlayers.push({
                                        own: true,
                                        save,
                                        name: lastPlayer.name,
                                        tower: _try(r.owntower, 'numbers') || lastPlayer.tower
                                    })
                                }
                            } else if (r.otherplayer && r.otherplayername) {
                                digestedPlayers.push({
                                    own: false,
                                    save: r.otherplayer.numbers,
                                    name: r.otherplayername.string,
                                    tower: null
                                })
                            }
                        }
                    }

                    for (const { header, rounds } of digestedFights) {
                        const fightType = header[0];

                        // Proceed only if type of fight is known to the system
                        if (Object.values(FIGHT_TYPES).includes(fightType)) {
                            // Parse fighters
                            const fighterA = new SFFighter(header.slice(05, 52), fightType);
                            const fighterB = new SFFighter(header.slice(52, 99), fightType);

                            // Parse individual rounds (group of 3 numbers)
                            const rawRounds = [];
                            for (let i = 0; i < rounds.length / 3; i++) {
                                rawRounds.push(_slice_len(rounds, i * 3, 3));
                            }

                            // Process each round
                            const processedRounds = [];
                            for (const [attackerId, attackType, targetHealthLeft] of rawRounds) {
                                const [attacker, target] = attackerId == fighterA.ID ? [fighterA, fighterB] : [fighterB, fighterA];

                                processedRounds.push(Object.assign({
                                    attacker,
                                    target,
                                    attackType,
                                    attackDamage: 0,
                                    targetHealthLeft,
                                }, decodeAttackType(attackType)));
                            }

                            const findHealth = (i) => {
                                const currentRound = processedRounds[i];
                                for (let j = i - 1, round; round = processedRounds[j]; j--) {
                                    if (round.attacker == currentRound.attacker && (round.attackType === ATTACK_REVIVE || !round.attackSpecial)) {
                                        return round.targetHealthLeft;
                                    }
                                }

                                return currentRound.target.Life;
                            }

                            // Finalize each round
                            let attackRageOffset = 0;
                            for (let i = 0, round; round = processedRounds[i]; i++) {
                                // Calculate attack damage
                                if (round.attackSpecial) {
                                    round.attackDamage = round.targetHealthLeft;
                                } else {
                                    round.attackDamage = findHealth(i) - round.targetHealthLeft;
                                }

                                // Calculate attack rage
                                if (round.attackSpecial) {
                                    attackRageOffset--;
                                } else if (round.attackChained) {
                                    attackRageOffset++;
                                }

                                round.attackRage = 1 + ((i + attackRageOffset) / 6);
                            }

                            // Push fight
                            currentFights.push({
                                fighterA,
                                fighterB,
                                rounds: processedRounds
                            })
                        }
                    }

                    // Convert all player data into actual player models and optionally companions
                    for (const data of digestedPlayers) {
                        const { own, save, name, tower } = data;

                        if (own) {
                            // Add own player
                            const player = new SFOwnPlayer(data);
                            currentPlayers.push(player);

                            // Add companions if present
                            if (player.Companions) {
                                currentPlayers.push(
                                    player.Companions.Bert,
                                    player.Companions.Mark,
                                    player.Companions.Kunigunde
                                )
                            }
                        } else {
                            // Add other player
                            const player = new SFOtherPlayer(data);
                            currentPlayers.push(player);
                        }
                    }
                }

                function render () {
                    $fightView.hide();

                    // Set winners
                    for (const fight of currentFights) {
                        fight.winner = fight.rounds[fight.rounds.length - 1].attacker;
                    }

                    // Compute hashes for all players and fighters
                    for (const [index, { fighterA, fighterB }] of Object.entries(currentFights)) {
                        fighterA.hash = computePlayerHash(fighterA);
                        fighterB.hash = computePlayerHash(fighterB);

                        currentFights[index].hash = `${fighterA.hash}-${fighterB.hash}`;
                    }

                    for (const player of currentPlayers) {
                        player.model = FighterModel.create(null, player);
                        player.hash = computePlayerHash(player);
                    }

                    // Merge fighters and hashes
                    for (const { fighterA, fighterB } of currentFights) {
                        const playerA = currentPlayers.find((player) => player.hash === fighterA.hash);
                        if (playerA) {
                            fighterA.player = playerA;
                        }

                        const playerB = currentPlayers.find((player) => player.hash === fighterB.hash);
                        if (playerB) {
                            fighterB.player = playerB;
                        }
                    }

                    // Group fights
                    const groupedFights = [];
                    for (const fight of currentFights) {
                        let group = groupedFights.find((group) => group.hash === fight.hash);

                        if (_nil(group)) {
                            group = {
                                hash: fight.hash,
                                fighterA: fight.fighterA,
                                fighterB: fight.fighterB,
                                fights: []
                            }

                            groupedFights.push(group);
                        }

                        group.fights.push({ rounds: fight.rounds, winner: fight.winner });
                    }

                    // Display in dropdown
                    $fightGroup.dropdown({
                        values: groupedFights.map((group, index) => ({
                            name: `${group.fighterA.Name} - ${group.fighterB.Name} (${group.fights.length})`,
                            value: index
                        }))
                    }).dropdown('setting', 'onChange', (value) => {
                        const group = groupedFights[parseInt(value)];

                        $fightView.show();

                        renderPlayer(group.fighterA, playerEditorA);
                        renderPlayer(group.fighterB, playerEditorB);

                        renderFightGroup(group);
                        renderButtons($viewSummaryGroup, group);
                    }).dropdown('set selected', '0');
                }

                function renderPlayer (player, editor) {
                    editor.fill(player.player || player);
                }

                function renderFight (group, fight) {
                    let content = '';

                    for (let i = 0; i < fight.rounds.length; i++) {
                        const { attacker, target, attackType, attackRage, attackDamage, attackBase, attackBaseError, attackMissed, attackCrit, attackSpecial, attackSecondary, targetHealthLeft } = fight.rounds[i];

                        const nameStyle = ' style="text-overflow: ellipsis; white-space: nowrap;"'

                        if (attackType === ATTACK_REVIVE) {
                            content += `
                                <tr${attacker.hash == group.fighterA.hash ? ' style="background-color: #202020; color: darkgray;"' : ''}>
                                    <td class="!text-center">${i + 1}</th>
                                    <td class="!text-center"></th>
                                    <td class="!text-center"${nameStyle}>${target.Name}</th>
                                    <td class="!text-center"></th>
                                    <td class="!text-center text-violet">${intl(`general.attack${attackType}`)}</th>
                                    <td class="!text-center"></th>
                                    <td class="!text-center">${Math.max(0, 100 * targetHealthLeft / target.Life).toFixed(1)}%</th>
                                    <td class="!text-center"></th>
                                </tr>
                            `;
                        } else if (attackType >= ATTACK_BARD_SONG) {
                            const spellNotes = Math.trunc((attackType % 100) / 10);
                            const spellLevel = attackType % 10;

                            content += `
                                <tr${attacker.hash == group.fighterA.hash ? ' style="background-color: #202020; color: darkgray;"' : ''}>
                                    <td class="!text-center">${i + 1}</th>
                                    <td class="!text-center"></th>
                                    <td class="!text-center"${nameStyle}>${attacker.Name}</th>
                                    <td class="!text-center"></th>
                                    <td class="!text-center text-violet">${intl(`general.attack200_2`, { spellNotes, spellLevel })}</th>
                                    <td class="!text-center"></th>
                                    <td class="!text-center"></th>
                                    <td class="!text-center"></th>
                                </tr>
                            `;
                        } else {
                            const attackClass = attackCrit ? ' text-orangered font-bold' : '';

                            const displayDamage = typeof attackBase === 'undefined' ? '' : formatAsSpacedNumber(attackDamage);
                            const displayBase = typeof attackBase === 'undefined' ? '' : formatAsSpacedNumber(attackBase);

                            content += `
                                <tr${attacker.hash == group.fighterA.hash ? ' style="background-color: #202020; color: darkgray;"' : ''}>
                                    <td class="!text-center">${i + 1}</th>
                                    <td class="!text-center">${attackRage.toFixed(2)}</th>
                                    <td class="!text-center"${nameStyle}>${attacker.Name}</th>
                                    <td class="!text-center"${nameStyle}>${target.Name}</th>
                                    <td class="!text-center${attackClass}">${intl(`general.attack${attackType}`)}</th>
                                    <td class="!text-center${attackClass}">${displayDamage}</th>
                                    <td class="!text-center">${Math.max(0, 100 * targetHealthLeft / target.Life).toFixed(1)}%</th>
                                    <td class="!text-center">${displayBase}${attackBaseError && !attackMissed ? ' <span class="text-orangered">!</span>' : ''}</th>
                                </tr>
                            `;
                        }
                    }

                    $fightTable.html(content);
                }

                function renderFightGroup (group) {
                    const selectBase = {
                        nameA: group.fighterA.Name,
                        healthA: formatAsSpacedNumber(group.fighterA.Life),
                        totalHealthA: formatAsSpacedNumber(group.fighterA.MaximumLife),
                        nameB: group.fighterB.Name,
                        healthB: formatAsSpacedNumber(group.fighterB.Life),
                        totalHealthB: formatAsSpacedNumber(group.fighterB.MaximumLife),
                    };

                    $fightList.dropdown({
                        values: group.fights.map((fight, index) => ({
                            name: intl('analyzer.table.select', Object.assign({ index: index + 1, rounds: fight.rounds.length, winner: fight.winner.Name }, selectBase)),
                            value: index
                        }))
                    }).dropdown('setting', 'onChange', (value) => {
                        const fight = group.fights[parseInt(value)];

                        currentGroup = group;
                        currentFight = fight;

                        updatePreview();
                        renderButtons($viewSummaryFight, group, fight);
                    }).dropdown('set selected', '0');
                }

                // Current data
                let currentFights = [];
                let currentPlayers = [];

                let currentGroup = null;
                let currentFight = null;

                function processGroup (group) {
                    // Fetch data and initialize models
                    const model1 = FighterModel.create(0, playerEditorA.read());
                    const model2 = FighterModel.create(1, playerEditorB.read());

                    // Initialize models
                    FighterModel.initializeFighters(model1, model2);

                    // Calculate base damage of each round
                    const flatRounds = group.fights.map((fight) => fight.rounds).flat();
                    for (const [index, round] of Object.entries(flatRounds)) {
                        if (round.attackType >= ATTACK_BARD_SONG) {
                            const spellLevel = round.attackType % 10 - 1;
                            const spellBonus = 1 + CONFIG.Bard.EffectValues[spellLevel] / 100;
                            const superRound = flatRounds[index - 1];

                            superRound.attackBase = Math.round(superRound.attackBase / spellBonus);

                            continue;
                        } else if (round.attackSpecial || round.attackMissed || round.attackType === ATTACK_FIREBALL) {
                            continue;
                        }

                        const model = round.attacker.hash === currentGroup.fighterA.hash ? model1 : model2;

                        // Scaled down weapon damage
                        let damage = round.attackDamage / round.attackRage / (round.attackSecondary ? model.Weapon2.Base : model.Weapon1.Base);

                        // Special cases
                        if (round.attackCrit) damage /= model.Critical;
                        if (round.attackType === ATTACK_SWOOP) damage /= CONFIG.Druid.SwoopMultiplier;

                        round.attackBase = Math.trunc(damage);
                    }

                    // Verify whether damage is in range
                    for (const round of flatRounds) {
                        if (round.attackSpecial || round.attackMissed || round.attackType === ATTACK_FIREBALL) {
                            continue;
                        }

                        const model = round.attacker.hash === currentGroup.fighterA.hash ? model1 : model2;
                        const weapon = model.Player.Items[round.attackSecondary ? 'Wpn2' : 'Wpn1'];

                        round.attackBaseError = !_within(round.attackBase, weapon.DamageMin, weapon.DamageMax);
                    }

                    // Prepare summary
                    for (const fighter of [group.fighterA, group.fighterB]) {
                        Object.assign(fighter, {
                            attacks: {},
                            damage: {
                                min: +Infinity,
                                max: -Infinity
                            }
                        });
                    }

                    // Calculate summary
                    for (const fight of group.fights) {
                        fight.fighterA = {
                            attacks: {},
                            damage: {
                                min: +Infinity,
                                max: -Infinity
                            }
                        }

                        fight.fighterB = {
                            attacks: {},
                            damage: {
                                min: +Infinity,
                                max: -Infinity
                            }
                        }

                        for (const { attacker, attackType, attackBase } of fight.rounds) {
                            const fightContainer = fight[group.fighterA.hash === attacker.hash ? 'fighterA' : 'fighterB'];
                            const groupContainer = group[group.fighterA.hash === attacker.hash ? 'fighterA' : 'fighterB'];

                            // Calculate type occurences
                            if (attackType < ATTACK_BARD_SONG && attackType !== ATTACK_FIREBALL && attackType !== ATTACK_FIREBALL_BLOCKED) {
                                fightContainer.attacks[attackType] = (fightContainer.attacks[attackType] || 0) + 1;
                                groupContainer.attacks[attackType] = (groupContainer.attacks[attackType] || 0) + 1;
                            }

                            // Calculate damage range
                            if (typeof attackBase !== 'undefined') {
                                const container3 = fightContainer.damage;
                                container3.min = Math.min(container3.min, attackBase);
                                container3.max = Math.max(container3.max, attackBase);
                                
                                const container4 = groupContainer.damage;
                                container4.min = Math.min(container4.min, attackBase);
                                container4.max = Math.max(container4.max, attackBase);
                            }
                        }
                    }
                }

                function updatePreview () {
                    if (currentGroup && currentFight) {
                        processGroup(currentGroup);
                        renderFight(currentGroup, currentFight);
                    }
                }

                function renderButtons ($element, group, fight) {
                    $element.off('click');
                    $element.click(() => {
                        if (currentGroup) {
                            DialogController.open(FightSummaryDialog, group, fight || group);
                        }
                    });
                }

                function importFights ({ players, fights }) {
                    currentPlayers.push(...players);
                    
                    for (const fight of fights) {
                        const mapping = {
                            [fight.fighterA.ID]: fight.fighterA,
                            [fight.fighterB.ID]: fight.fighterB
                        };

                        // Fill in all attacker & target data for each round
                        for (const round of fight.rounds) {
                            round.attacker = mapping[round.attackerId];
                            round.target = mapping[round.targetId];
                        }

                        currentFights.push(fight);
                    }
                }

                const FIGHTER_WHITELIST = [
                    'ID', 'Name', 'Level', 'MaximumLife', 'Life',
                    'Strength', 'Dexterity', 'Intelligence', 'Constitution',
                    'Luck', 'Class', 'Wpn1', 'Wpn2'
                ];

                const ROUND_WHITELIST = [
                    'attackChained', 'attackCrit', 'attackDamage', 'attackMissed',
                    'attackRage', 'attackSecondary', 'attackSpecial', 'attackType',
                    'targetHealthLeft', 'attackerSpecialState'
                ];

                function cleanCopy (rawObject, whitelist) {
                    const object = {};
                    for (const field of whitelist) {
                        object[field] = rawObject[field];
                    }

                    return object;
                }

                function exportFights (source) {
                    // Assemble fights
                    const assembledFights = Array.isArray(source) ? source : source.fights.map((fight) => Object.assign({}, fight, source));

                    // Collect all players and fights
                    const exportFights = [];
                    const exportPlayers = {};

                    for (const { fighterA, fighterB, rounds, winner } of assembledFights) {
                        // Collect players
                        if (fighterA.player) {
                            exportPlayers[fighterA.hash] = toSimulatorModel(fighterA.player);
                        }

                        if (fighterB.player) {
                            exportPlayers[fighterB.hash] = toSimulatorModel(fighterB.player);
                        }

                        // Collect fight
                        exportFights.push({
                            fighterA: cleanCopy(fighterA, FIGHTER_WHITELIST),
                            fighterB: cleanCopy(fighterB, FIGHTER_WHITELIST),
                            rounds: rounds.map((round) => Object.assign(cleanCopy(round, ROUND_WHITELIST), {
                                attackerId: round.attacker.ID,
                                targetId: round.target.ID
                            }))
                        })
                    }    
                    
                    // Export
                    Exporter.json({
                        players: Object.values(exportPlayers),
                        fights: exportFights
                    });
                }
            })
        </script>
    </body>
</html>
